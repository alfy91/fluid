fun append {
   [] ys → ys;
   Cons(x, xs) ys → [x, ...append xs ys]
};

fun compose f g x → 
   f (g x);

fun concat {
   [] ys → ys;
   Cons(x, xs) ys → [x, ...concat xs ys]
};

fun filter p {
   [] → [];
   Cons(x, xs) →
      match p x as {
         True → [x, ...filter p xs];
         False → filter p xs
      }
};

fun foldr op z {
   [] → z;
   Cons(x, xs) → op (x, foldr op z xs)
};

fun id x → 
   x;

fun intersperse {
   [] sep → [];
   Cons(x, []) sep → [x];
   Cons(x, Cons(y, ys)) sep → [x, sep, ...intersperse Cons(y, ys)]
};

fun iterate n f x → match n == 0 as {
   True → [];
   False → [x, ...map f (iterate (n - 1) f x)]
};

fun length {
   [] → 0;
   Cons(x, xs) → 1 + length xs
};

fun map f {
   [] → [];
   Cons(x, xs) → [f x, ...map f xs]
};

fun repeat n → 
   iterate n id;

fun reverse {
   [] → [];
   Cons(x, xs) → append (reverse xs) [x]
};

// delete when we reinstate projection functions
fun tail 
   Cons(x, xs) → xs;

fun zipW op {
   [] ys → [];
   Cons(x, xs) {
      [] → [];
      Cons(y, ys) → [op(x, y), ...zipW op xs ys]
   }
}

