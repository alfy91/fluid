// List(a) → List(a) → List(a)
// (b → c) → (a → b) → a → c
// Would like infix operators. 
fun compose f g x → 
   f (g x);

fun concat {
   [] ys → ys;
   [x, ...xs] ys → [x, ...concat xs ys]
};

fun filter p {
   [] → [];
   [x, ...xs] →
      match p x as {
         True → [x, ...filter p xs];
         False → filter p xs
      }
};

// (a → b) → Pair(a, c) → Pair(b, c)
fun first f (a, c) → 
   (f a, c);


fun foldr op z {
   [] → z;
   [x, ...xs] → op (x, foldr op z xs)
};

fun foldr1 op {
   [x] → x;
   [x, y, ...xs] → op (x, foldr1 op [y, ...xs])
};

fun fst (x, y) → 
   x;

fun head [x, ...xs] → 
   x;

fun id x → 
   x;

fun intersperse {
   [] sep → [];
   [x] sep → [x];
   [x, y, ...ys] sep → [x, sep, ...intersperse [y, ...ys]]
};

fun iterate n f x → match n == 0 as {
   True → [];
   False → [x, ...map f (iterate (n - 1) f x)]
};

fun length {
   [] → 0;
   [x, ...xs] → 1 + length xs
};

fun map f {
   [] → [];
   [x, ...xs] → [f x, ...map f xs]
};

fun max xs →
   foldr1 (fun (n, m) → match n > m as { True → n; False → m }) xs;

fun repeat n → 
   iterate n id;

fun reverse {
   [] → [];
   [x, ...xs] → concat (reverse xs) [x]
};

// (a → b) → Pair(c, a) → Pair(c, b)
fun second f (c, a) → 
   (c, f a);

fun snd (x, y) → 
   y;

// List(number) → number
fun sum xs → 
   foldr (fun (x, y) → x + y) 0 xs;

fun swap (a, b) →
   (b, a);

fun tail [x, ...xs] → 
   xs;

// List(Pair(a, b)) → Pair(List(a), List(b))
fun unzip {
   [] → ([], []);
   [(x, y), ...xys] → 
      match unzip xys as (xs, ys) → ([x, ...xs], [y, ...ys])
};

fun zipW op {
   [] ys → [];
   [x, ...xs] {
      [] → [];
      [y, ...ys] → [op(x, y), ...zipW op xs ys]
   }
}
