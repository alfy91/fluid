// List(Pair(number, number)) → Pair(number, number)
let pathDimensions = fun ps → 
   match unzip ps as (xs, ys) → (max xs, max ys);

let scale = fun x y g →
   Transform(Scale(x, y), g);

let translate = fun x y g →
   Transform(Translate(x, y), g);

let transpose = fun g →
   Transform(Transpose, g);

letrec
   // GraphicElement → Pair(number, number)
   fun dimensions {
      Polyline(ps) → 
         pathDimensions (map (fun Point(x, y) → (x, y)) ps);
      Polygon(ps) →
         pathDimensions (map (fun Point(x, y) → (x, y)) ps);
      Graphic(gs) → 
         pathDimensions (map dimensions gs);
      Transform(Scale(x, y), g) → 
         match dimensions g as (w, h) → (w * x, h * y);
      Transform(Translate(x, y), g) → 
         match dimensions g as (w, h) → (w + x, h + y);
      Transform(Transpose, g) → 
         swap (dimensions g)
   };

// GraphicsElement → number
let width = fun g → 
   fst (dimensions g);

// number → List(GraphicsElement) → List(GraphicsElement)
let spaceRight = fun sep gs →
   zipW (fun (x, g) → translate x 0 g) (iterate (length gs) (fun x → x + sep) 0) gs;

// Unlike spaceRight, produces a nested structure.
// List(GraphicsElement) → Graphic
let stackRight = fun gs →
   foldr (fun (g, g') → Graphic([g, translate (width g) 0 g'])) Graphic([]) gs;

// Negatively offset from (0, 0) by margin; client code responsible for translating into positive space (if desired).
// number → number → number → GraphicElement
let x_axis = fun margin n width tickHeight →
   let tick = Polyline([Point(0, 0), Point(0, 0 - tickHeight)]) in
   let ticks = fun n → spaceRight width (repeat n tick) in
   let line = Polyline([Point(0, 0), Point(n * width, 0)]) in
   translate 0 (0 - margin) Graphic([line, ...ticks n]);

// GraphicsElement → number
let height = fun g → snd (dimensions g);

// LinearTransform → LinearTransform
let invert = fun {
   Scale(x, y) → Scale(1 / x, 1 / y);           // unfortunately not a true inverse..
   Translate(x, y) → Translate(0 - x, 0 - y);   // no unary negation yet
   Transpose → Transpose                        // self-involutive
};

// (0,0)-based cross used to render points of a line plot.
// number → Graphic
let plotPoint = fun radius → 
   Graphic([
      Polyline([Point(0 - radius, 0 - radius), Point(radius, radius)]),
      Polyline([Point(0 - radius, radius), Point(radius, 0 - radius)])
   ]);

// List(Point) → LinearTransform → Graphic
let linePlot = fun t ps →
   let points = map (fun Point(x, y) → translate x y (Transform(invert t, plotPoint 2.5))) ps in 
   Transform(t, Graphic([Polyline(ps), ...points]));

// Rect → List(Point)
let rectPath = fun Rect(w, h) →
   [Point(0, 0), Point(w, 0), Point(w, h), Point(0, h)];

// Rect → Polygon
let renderRect = fun r → 
   let ps = rectPath r in Polygon(ps)
