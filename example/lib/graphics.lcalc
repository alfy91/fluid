// List(Point) → List(Point)
fun close [x, ...xs] → concat [x, ...xs] [x];

// GraphicElement → Pair(number, number)
fun dimensions {
   PathStroke(ps) → 
      pathDimensions (map (fun Point(x, y) → (x, y)) ps);
   RectFill(ps) →
      pathDimensions (map (fun Point(x, y) → (x, y)) ps);
   Scale(x, y, g) → 
      match dimensions g as (w, h) → (w * x, h * y);
   Translate(x, y, g) → 
      match dimensions g as (w, h) → (w + x, h + y);
   Transpose(g) → 
      swap (dimensions g);
   Graphic(gs) → 
      pathDimensions (map dimensions gs)
};

// GraphicsElement → number
fun height g → snd (dimensions g);

// List(Pair(number, number)) → Pair(number, number)
fun pathDimensions ps → 
   match unzip ps as (xs, ys) → (max xs, max ys);

// The cross used for rendering the points of a line plot.
// number → Point → Graphic
fun plotPoint radius Point(x, y) → 
   Graphic([
      PathStroke([Point(x - radius, y - radius), Point(x + radius, y + radius)]),
      PathStroke([Point(x - radius, y + radius), Point(x + radius, y - radius)])
   ]);

// Rect → List(Point)
fun rectPath Rect(w, h) → 
   [Point(0, 0), Point(w, 0), Point(w, h), Point(0, h)];

// List(Point) → Graphic
fun linePlot ps → 
   Graphic([PathStroke(ps), ...map (plotPoint 0.16) ps]);

// Rect → Graphic
fun renderRect r → 
   let ps = rectPath r in Graphic([RectFill(ps), PathStroke(close(ps))]);

// number → List(GraphicsElement) → List(GraphicsElement)
fun spaceRight sep gs →
   zipW (fun (x, g) → Translate(x, 0, g)) (iterate (length gs) (fun x → x + sep) 0) gs;

// Unlike spaceRight, produces a nested structure.
// List(GraphicsElement) → Graphic
fun stackRight gs →
   foldr (fun (g, g') → Graphic([g, Translate(width g, 0, g')])) Graphic([]) gs;

// GraphicsElement → number
fun width g → fst (dimensions g);

// Negatively offset from (0, 0) by margin from (0, 0); client code responsible for translating into positive space (if desired).
// number → number → number → GraphicElement
fun x_axis margin n width tickHeight →
   let tick = PathStroke([Point(0, 0), Point(0, 0 - tickHeight)]) in
   let ticks = fun n → spaceRight width (repeat n tick) in
   let line = PathStroke([Point(0, 0), Point(n * width, 0)]) in
   Translate(0, 0 - margin, Graphic([line, ...ticks n]))
