// Simplistic but something more general may require primitives which take data values as inputs.
// Application module GraphicsRenderer must be loaded for these definitions to work.
// Str → Num
primitive textWidth;

// Str → Num
primitive textHeight;

// List (Num, Num) → (Num, Num)
let pathDimensions = fun ps → 
   match unzip ps as (xs, ys) → (max xs, max ys);

// Num → GraphicsElement → GraphicsElement
let x_translate = fun x g → Translate(x, 0, g);

// Num → GraphicsElement → GraphicsElement
let y_translate = fun y g → Translate(0, y, g);

// Point → Point
let transposePoint = fun Point(x, y) → Point(y, x);

// Not a true linear transformation, because text isn't reflected; positions only.
// GraphicsElement → GraphicsElement
letrec fun transpose {
   Polyline(ps) → Polyline(map transposePoint ps);
   Polygon(ps) → Polygon(map transposePoint ps);
   Graphic(gs) → Graphic(map transpose gs);
   Text(x, y, str) → Text(y, x, str);
   Translate(x, y, g) → Translate(y, x, transpose g)
};

// See GitHub issue #167.
// GraphicsElement → (Num, Num)
letrec fun dimensions {
   Polyline(ps) → 
      pathDimensions (map (fun Point(x, y) → (x, y)) ps);
   Polygon(ps) →
      pathDimensions (map (fun Point(x, y) → (x, y)) ps);
   Graphic(gs) → 
      pathDimensions (map dimensions gs);
   Text(x, y, str) → (textWidth str, textHeight str);
   Translate(x, y, g) →
      match dimensions g as (w, h) → (w + x, h + y)
};

// GraphicsElement → Num
let width = compose fst dimensions;

// GraphicsElement → Num
let height = compose snd dimensions;

// Num → List GraphicsElement → List GraphicsElement
let spaceRight = fun sep gs →
   zipW (uncurry x_translate) (iterate (length gs) (fun x → x + sep) 0) gs;

// Unlike spaceRight, produces a nested structure.
// List GraphicsElement → Graphic
let stackRight = fun gs →
   foldr (fun (g, g') → Graphic([g, x_translate (width g) g'])) Graphic([]) gs;

// Rect → Polygon
let renderRect = fun Rect(w, h) → 
   Polygon([Point(0, 0), Point(w, 0), Point(w, h), Point(0, h)]);

let horizLine = fun x x' →
   Polyline([Point(x, 0), Point(x', 0)]);

let vertLine = fun y y' →
   Polyline([Point(0, y), Point(0, y')]);

// Heuristic saying how often to place a tick on an axis of length n.
// Num → Num
let tickEvery = fun n →
   let m = floor (logBase 10 n) in
   match n <= 2 * 10 ** m as {
      True → 2 * 10 ** (m - 1);
      False → 10 ** m
   };

// Return negative offset from x-axis; caller responsible for translating into positive space (if desired).
// Num → Num → (Num, Num) → Num → Num → (GraphicsElement, Num)
let x_axis = fun scale margin (start, end) tickSp tickLength →
   let tickSp' = tickSp * scale;
   let tick = vertLine 0 (0 - tickLength);
   let firstTick = ceilingTo start tickSp;
   let n = floor ((end - firstTick) / tickSp) + 1;
   let ticks = spaceRight tickSp' (repeat n tick);
   let labels = map 
      (fun x → let str = numToStr x in Text((0 - textWidth str) / 2, 0 - tickLength - textHeight str, str))
      (iterate n (fun x → x + tickSp) firstTick);
   let labelHeight = 0 - max (map (fun Text(x, y, str) → y) labels);
   let labels' = spaceRight tickSp' labels;
   let line = horizLine 0 ((end - start) * scale);
   let axis = Graphic([line, x_translate ((firstTick - start) * scale) Graphic(concat ticks labels')])
   in
   (y_translate (0 - margin) axis, margin + tickLength + labelHeight);

// Some numerical constants for charts; should parameterise by these instead.
let tickLength = 4;
let axisMargin = 0;

// List (Str, Num) → Num
let maxVal = compose max (map snd);

// Bar graph with categorical x-axis; before scaling, bars have unit spacing but are narrower.
// (Num, Num) → List (Str, Num) → GraphicsElement
let barGraph = fun (x_scale, y_scale) catData →
   match x_axis x_scale axisMargin (0.5, length catData + 0.5) 1 tickLength as (x_ax, x_offset) →
   let y_max = maxVal catData in 
   match first transpose (x_axis y_scale axisMargin (0, y_max) (tickEvery y_max) tickLength) as (y_ax, y_offset) →
   let shrinkBy = 0.75; // ratio of bar width to bar spacing
   let bars = x_translate (((1 - shrinkBy) / 2) * x_scale) // centre bars
      Graphic(spaceRight x_scale (map (fun (k, v) → renderRect Rect(shrinkBy * x_scale, v * y_scale)) catData))
   in
   Translate(x_offset, y_offset, Graphic([bars, x_ax, y_ax]));

// (0,0)-based cross used to render points of a line plot.
// Num → GraphicsElement
let plotPoint = fun radius →
   Graphic([
      Polyline([Point(0 - radius, 0 - radius), Point(radius, radius)]),
      Polyline([Point(0 - radius, radius), Point(radius, 0 - radius)])
   ]);

// List Point → (Num, Num) → GraphicsElement
let linePlot = fun (x_scale, y_scale) ps →
   let ps' = map (fun Point(x, y) → Point(x * x_scale, y * y_scale)) ps;
   let points = map (fun Point(x, y) → Translate(x, y, plotPoint 2.5)) ps'
   in
   Graphic([Polyline(ps'), ...points]);

// (Num, Num) → List (Num, Num) → Num → GraphicsElement
let lineGraph = fun (x_scale, y_scale) x_start numData →
   match x_axis x_scale axisMargin (x_start, fst (last numData)) 1 tickLength as (x_ax, x_offset) →
   let y_max = maxVal numData in 
   match first transpose (x_axis y_scale axisMargin (0, y_max) (tickEvery y_max) tickLength) as (y_ax, y_offset) →
   let ps = map (fun (x, y) → Point(x - x_start, y)) numData in
   Translate(x_offset, y_offset, Graphic([linePlot (x_scale, y_scale) ps, x_ax, y_ax]))
