// List(Pair(Num, Num)) → Pair(Num, Num)
let pathDimensions = fun ps → 
   match unzip ps as (xs, ys) → (max xs, max ys);

// Num → Num → GraphicsElement → GraphicsElement
let scale = fun x y g →
   Transform(Scale(x, y), g);

// Num → Num → GraphicsElement → GraphicsElement
let translate = fun x y g →
   Transform(Translate(x, y), g);

// Num → GraphicsElement → GraphicsElement
let transpose = fun g →
   Transform(Transpose, g);

letrec
   // GraphicsElement → Pair(Num, Num)
   fun dimensions {
      Polyline(ps) → 
         pathDimensions (map (fun Point(x, y) → (x, y)) ps);
      Polygon(ps) →
         pathDimensions (map (fun Point(x, y) → (x, y)) ps);
      Graphic(gs) → 
         pathDimensions (map dimensions gs);
      Transform(Scale(x, y), g) → 
         match dimensions g as (w, h) → (w * x, h * y);
      Transform(Translate(x, y), g) → 
         match dimensions g as (w, h) → (w + x, h + y);
      Transform(Transpose, g) → 
         swap (dimensions g)
   };

// GraphicsElement → Num
let width = fun g → 
   fst (dimensions g);

// Num → List(GraphicsElement) → List(GraphicsElement)
let spaceRight = fun sep gs →
   zipW (fun (x, g) → translate x 0 g) (iterate (length gs) (fun x → x + sep) 0) gs;

// Unlike spaceRight, produces a nested structure.
// List(GraphicsElement) → Graphic
let stackRight = fun gs →
   foldr (fun (g, g') → Graphic([g, translate (width g) 0 g'])) Graphic([]) gs;

// GraphicsElement → Num
let height = fun g → snd (dimensions g);

// LinearTransform → LinearTransform
let invert = fun {
   Scale(x, y) → Scale(1 / x, 1 / y);           // unfortunately not a true inverse..
   Translate(x, y) → Translate(0 - x, 0 - y);   // no unary negation yet
   Transpose → Transpose                        // self-involutive
};

// (0,0)-based cross used to render points of a line plot.
// Num → GraphicsElement
let plotPoint = fun radius → 
   Graphic([
      Polyline([Point(0 - radius, 0 - radius), Point(radius, radius)]),
      Polyline([Point(0 - radius, radius), Point(radius, 0 - radius)])
   ]);

// List(Point) → LinearTransform → GraphicsElement
let linePlot = fun t ps →
   let points = map (fun Point(x, y) → translate x y (Transform(invert t, plotPoint 2.5))) ps in 
   Transform(t, Graphic([Polyline(ps), ...points]));

// Rect → Polygon
let renderRect = fun Rect(w, h) → 
   Polygon([Point(0, 0), Point(w, 0), Point(w, h), Point(0, h)]);

// Heuristic saying how often to place a tick on an axis of length n.
// Num → Num
let tickEvery = fun n →
   let m = floor (logBase 10 n) in
   match n <= 2 * 10 ** m as {
      True → 2 ** 10 (m - 1);
      False → 10 ** m
   };

// Negatively offset from x-axis by margin + tickHeight; caller responsible for translating into positive 
// space (if desired).
// Num → Num → Num → GraphicsElement
let x_axis = fun margin x_start x_max tickSp tickLength →
   let tick = Polyline([Point(0, 0), Point(0, 0 - tickLength)]);
   let ticks = spaceRight tickSp (repeat (ceiling ((x_max - x_start) / tickSp)) tick);
   let line = Polyline([Point(0, 0), Point(x_max - x_start, 0)]) in
   translate 0 (0 - margin) Graphic([line, translate x_start 0 Graphic(ticks)]);

// Some numerical constants for charts; should parameterise by these instead.
let tickLength = 4;
let axis_margin = 2;
let x_offset = axis_margin + tickLength;
let y_offset = x_offset;

// List(Pair(Str, Num)) → Num
let maxVal = compose max (map snd);

// Bar graph with categorical x-axis; before scaling, bars have unit spacing but are narrower.
// Pair(Num, Num) → List(Pair(Str, Num)) → GraphicsElement
let barGraph = fun (x_scale, y_scale) catData →
   let x_ax = x_axis axis_margin 0.5 (length catData + 0.5) 1 tickLength;
   let y_ax = let y_max = maxVal catData in transpose (x_axis axis_margin 0 y_max (tickEvery y_max) tickLength);
   let shrinkBy = 0.75; // ratio of bar width to bar spacing
   let bars = translate ((1 - shrinkBy) / 2) 0 // centre bars
      Graphic(spaceRight 1 (map (fun (k, v) → renderRect Rect(shrinkBy, v)) catData))
   in
   translate x_offset y_offset Graphic([
      scale x_scale 1 x_ax, 
      scale 1 y_scale y_ax,
      scale x_scale y_scale bars
   ]);

// Pair(Num, Num) → List(Pair(Num, Num)) → Num → GraphicsElement
let lineGraph = fun (x_scale, y_scale) x_start numData →
   let ps = map (fun (x, y) → Point(x - x_start, y)) numData in
   translate x_offset y_offset (linePlot Scale(x_scale, y_scale) ps)
