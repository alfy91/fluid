// Simplistic but something more general may require primitives which take data values as inputs.
// Application module GraphicsRenderer must be loaded for these definitions to work.
// Str → Num
primitive textWidth;

// Str → Num
primitive textHeight;

// List(Pair(Num, Num)) → Pair(Num, Num)
let pathDimensions = fun ps → 
   match unzip ps as (xs, ys) → (max xs, max ys);

// Num → Num → GraphicsElement → GraphicsElement
let scale = fun x y g →
   Transform(Scale(x, y), g);

// Num → Num → GraphicsElement → GraphicsElement
let translate = fun x y g →
   Transform(Translate(x, y), g);

// Num → GraphicsElement → GraphicsElement
let x_translate = flip translate 0;

// Num → GraphicsElement → GraphicsElement
let y_translate = translate 0;

// Num → GraphicsElement → GraphicsElement
let transpose = fun g →
   Transform(Transpose, g);

// TODO: borked.
// GraphicsElement → Pair(Num, Num)
letrec fun dimensions {
   Polyline(ps) → 
      pathDimensions (map (fun Point(x, y) → (x, y)) ps);
   Polygon(ps) →
      pathDimensions (map (fun Point(x, y) → (x, y)) ps);
   Graphic(gs) → 
      pathDimensions (map dimensions gs);
   Text(x, y, str) → (textWidth str, textHeight str);
   Transform(Scale(x, y), g) → 
      match dimensions g as (w, h) → (w * x, h * y);
   Transform(Translate(x, y), g) → 
      match dimensions g as (w, h) → (w + x, h + y);
   Transform(Transpose, g) → 
      swap (dimensions g)
};

// GraphicsElement → Num
let width = compose fst dimensions;

// GraphicsElement → Num
let height = compose snd dimensions;

// Num → List(GraphicsElement) → List(GraphicsElement)
let spaceRight = fun sep gs →
   zipW (fun (x, g) → x_translate x g) (iterate (length gs) (fun x → x + sep) 0) gs;

// Unlike spaceRight, produces a nested structure.
// List(GraphicsElement) → Graphic
let stackRight = fun gs →
   foldr (fun (g, g') → Graphic([g, x_translate (width g) g'])) Graphic([]) gs;

// LinearTransform → LinearTransform
let invert = fun {
   Scale(x, y) → Scale(1 / x, 1 / y);           // unfortunately not a true inverse..
   Translate(x, y) → Translate(0 - x, 0 - y);   // no unary negation yet
   Transpose → Transpose                        // self-involutive
};

// Rect → Polygon
let renderRect = fun Rect(w, h) → 
   Polygon([Point(0, 0), Point(w, 0), Point(w, h), Point(0, h)]);

let horizLine = fun x x' →
   Polyline([Point(x, 0), Point(x', 0)]);

let vertLine = fun y y' →
   Polyline([Point(0, y), Point(0, y')]);

// Heuristic saying how often to place a tick on an axis of length n.
// Num → Num
let tickEvery = fun n →
   let m = floor (logBase 10 n) in
   match n <= 2 * 10 ** m as {
      True → 2 * 10 ** (m - 1);
      False → 10 ** m
   };

// Return negative offset from x-axis; caller responsible for translating into positive space (if desired).
// Num → Num → Num → Pair(GraphicsElement, Num)
let x_axis = fun x_scale margin x_start x_max tickSp tickLength →
   let x_start' = x_start * x_scale;
   let x_max' = x_max * x_scale;
   let tickSp' = tickSp * x_scale;
   let tick = vertLine 0 (0 - tickLength);
   let n = ceiling ((x_max' - x_start') / tickSp');
   let ticks = spaceRight tickSp' (repeat n tick);
   let labels = spaceRight tickSp' (map (fun x → Text(0, 0, numToStr x)) (iterate n (fun x → x + tickSp) 0));
   let line = horizLine 0 (x_max' - x_start');
   let axis = y_translate (0 - margin) Graphic([line, x_translate x_start' Graphic(concat ticks labels)]) 
   in
   (axis, margin + tickLength);

// Some numerical constants for charts; should parameterise by these instead.
let tickLength = 4;
let axisMargin = 0;

// List(Pair(Str, Num)) → Num
let maxVal = compose max (map snd);

// Bar graph with categorical x-axis; before scaling, bars have unit spacing but are narrower.
// Pair(Num, Num) → List(Pair(Str, Num)) → GraphicsElement
let barGraph = fun (x_scale, y_scale) catData →
   match x_axis x_scale axisMargin 0.5 (length catData + 0.5) 1 tickLength as (x_ax, x_offset) →
   let y_max = maxVal catData in 
   match first transpose (x_axis y_scale axisMargin 0 y_max (tickEvery y_max) tickLength) as (y_ax, y_offset) →
   let shrinkBy = 0.75; // ratio of bar width to bar spacing
   let bars = x_translate (((1 - shrinkBy) / 2) * x_scale) // centre bars
      Graphic(spaceRight x_scale (map (fun (k, v) → renderRect Rect(shrinkBy * x_scale, v * y_scale)) catData))
   in
   translate x_offset y_offset Graphic([bars, x_ax, y_ax]);

// (0,0)-based cross used to render points of a line plot.
// Num → GraphicsElement
let plotPoint = fun radius →
   Graphic([
      Polyline([Point(0 - radius, 0 - radius), Point(radius, radius)]),
      Polyline([Point(0 - radius, radius), Point(radius, 0 - radius)])
   ]);

// List(Point) → LinearTransform → GraphicsElement
let linePlot = fun t ps →
   let points = map (fun Point(x, y) → translate x y (Transform(invert t, plotPoint 2.5))) ps in 
   Transform(t, Graphic([Polyline(ps), ...points]));

// TODO: delete these once we add axes to line graphs.
let x_offset = axisMargin + tickLength;
let y_offset = x_offset;

// Pair(Num, Num) → List(Pair(Num, Num)) → Num → GraphicsElement
let lineGraph = fun (x_scale, y_scale) x_start numData →
   let ps = map (fun (x, y) → Point(x - x_start, y)) numData in
   translate x_offset y_offset (linePlot Scale(x_scale, y_scale) ps)
