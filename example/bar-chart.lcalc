// typedef Year = number
// typedef Country = string
// typedef EnergyType = string
// typedef Output = number
// typedef Data = List(Pair(Year, AnnualData))
// typedef AnnualData = List(Pair(Country, CountryData))
// typedef CountryData = List(Pair(EnergyType, Output)) 
// The original dataset sometimes has '~0' instead of '0'. Including only 3 top countries here.
let
   data = [
      // http://www.ren21.net/gsr-2016/00-Reference-Tables.php
      (2015, [
         ("China", [
            ("Bio", 10.3),
            ("Geothermal", 0),
            ("Hydro", 296),
            ("Ocean", 0),
            ("Solar", 44),
            ("CSP", 0),
            ("Wind", 145)
         ]),
         ("United States", [
            ("Bio", 16.7),
            ("Geothermal", 3.6),
            ("Hydro", 80),
            ("Ocean", 0),
            ("Solar", 26),
            ("CSP", 1.7),
            ("Wind", 74)
         ]),
         ("Germany", [
            ("Bio", 7.1),
            ("Geothermal", 0),
            ("Hydro", 5.6),
            ("Ocean", 0),
            ("Solar", 40),
            ("CSP", 0),
            ("Wind", 45)
         ]),
         ("Japan", [
            ("Bio", 4.8),
            ("Geothermal", 0.5),
            ("Hydro", 22),
            ("Ocean", 0),
            ("Solar", 34),
            ("CSP", 0),
            ("Wind", 3)
         ])
      ]),
      // http://www.ren21.net/gsr-2017/pages/tables/tables/#table-R2
      (2016, [
         ("China", [
            ("Bio", 12),
            ("Geothermal", 0),
            ("Hydro", 305),
            ("Ocean", 0),
            ("Solar", 77),
            ("CSP", 0),
            ("Wind", 169)
         ]),
         ("United States", [
            ("Bio", 16.8),
            ("Geothermal", 3.6),
            ("Hydro", 80),
            ("Ocean", 0),
            ("Solar", 41),
            ("CSP", 1.7),
            ("Wind", 82)
         ]),
         ("Germany", [
            ("Bio", 7.6),
            ("Geothermal", 0),
            ("Hydro", 5.6),
            ("Ocean", 0),
            ("Solar", 41),
            ("CSP", 0),
            ("Wind", 50)
         ]),
         ("Japan", [
            ("Bio", 4.1),
            ("Geothermal", 0.5),
            ("Hydro", 23),
            ("Ocean", 0),
            ("Solar", 43),
            ("CSP", 0),
            ("Wind", 3.2)
         ])
      ]),
      // http://www.ren21.net/gsr-2018/pages/tables/tables/#Table_R2
      (2017, [
         ("China", [
            ("Bio", 14.9),
            ("Geothermal", 0),
            ("Hydro", 313),
            ("Ocean", 0),
            ("Solar", 131),
            ("CSP", 0),
            ("Wind", 188)
         ]),
         ("United States", [
            ("Bio", 16.7),
            ("Geothermal", 2.5),
            ("Hydro", 80),
            ("Ocean", 0),
            ("Solar", 51),
            ("CSP", 1.7),
            ("Wind", 89)
         ]),
         ("Germany", [
            ("Bio", 8),
            ("Geothermal", 0),
            ("Hydro", 5.6),
            ("Ocean", 0),
            ("Solar", 42),
            ("CSP", 0),
            ("Wind", 56)
         ]),
         ("Japan", [
            ("Bio", 3.6),
            ("Geothermal", 0.5),
            ("Hydro", 23),
            ("Ocean", 0),
            ("Solar", 49),
            ("CSP", 0),
            ("Wind", 3.4)
         ])
      ])
   ];
letrec 
   // Put data into a map instead?
   fun lookupStr k [(k', v), ...kvs] → 
      match k === k' as {
         True → v;
         False → lookupStr k kvs
      };
   fun lookupNum k [(k', v), ...kvs] → 
      match k == k' as {
         True → v;
         False → lookupNum k kvs
      };
// CountryData → Output
let countryTotal = compose sum (map snd);
// AnnualData → Output
let annualTotal = compose sum (map (compose countryTotal snd));
let countryData = map (second countryTotal) (lookupNum 2015 data);
// Data → Year
let firstYear = head (map fst data);
let ps = map (fun (year, annualData) → Point(year - firstYear, annualTotal annualData)) data;
let y_scale = 1 / 6;
let x_scale = 30;
let tickLength = 8;
let axis_margin = 5;
let x_offset = axis_margin + tickLength;
let y_offset = x_offset;
let barGraph = fun (x_scale, y_scale) catData →
   translate x_offset y_offset Graphic([
      scale x_scale 1 (x_axis axis_margin (length catData + 1) 1.16 tickLength),
      transpose (scale x_scale 1 (x_axis axis_margin 4 1 tickLength)),
      scale x_scale y_scale Graphic(spaceRight 1.16 (map (fun (k, v) → renderRect Rect(1, v)) catData))
   ]);
let lineGraph =
   translate x_offset y_offset (linePlot Scale(x_scale, y_scale) ps)
in
stackRight [barGraph (x_scale, y_scale) countryData, lineGraph]
