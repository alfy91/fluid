let
   data = Cons((2001, 15), Cons((2002, 8), Cons((2005, 22), Cons((2007, 9), Nil))))
in
let id = fun x → x in
letrec 
   fun concat {
      Nil ys → ys;
      Cons(x, xs) ys → Cons(x, concat xs ys)
   };
   fun map f {
      Nil → Nil;
      Cons(x, xs) → Cons(f x, map f xs)
   };
   fun zipW op {
      Nil ys → Nil;
      Cons(x, xs) {
         Nil → Nil;
         Cons(y, ys) → Cons(op(x, y), zipW op xs ys)
      }
   };
   fun iterate n f x → match n == 0 as {
      True → Nil;
      False → Cons(x, map f (iterate (n - 1) f x))
   };
   fun length {
      Nil → 0;
      Cons(x, xs) → 1 + length xs
   }
in 
let repeat = fun n → iterate n id in
// Field accessors/updaters
let tail = fun Cons(x, xs) → xs in
let point_get_x = fun Point(x, y) → x in
let point_put_x = fun x Point(_, y) → Point(x, y) in
let rect_get_x = fun Rect(x, y, w, h) → x in
let rect_put_x = fun x Rect(_, y, w, h) → Rect(x, y, w, h) in
let rect_get_w = fun Rect(x, y, w, h) → w in
let incr = fun x get put shape → put (get shape + x) shape in 
let transpose = fun Point(x, y) → Point(y, x) in 
let translate = fun (dx, dy) Point(x, y) → Point(x + dx, y + dy) in 
let
   // discard x coordinates other than the first
   stackRight = fun sep get_x put_x get_w →
      letrec 
         fun stackRight' {
            Nil → Nil;
            Cons(shape, Nil) → Cons(shape, Nil);
            Cons(shape, Cons(shape2, shapes)) → 
               Cons(shape, stackRight' Cons(put_x ((get_x shape) + (get_w shape) + sep) shape2, shapes))
         } 
      in 
      stackRight'
in
// these two operate on abstract shapes (that support an x property), preserving their type
let
   // drop all x coordinates
   spaceRight = fun sep put_x shapes →
      zipW (fun (x, shape) → put_x x shape) (iterate (length shapes) (fun x → x + sep) 0) shapes
in
let
   // discard x coordinates other than the first
   spaceRight' = fun sep get_x put_x Cons(shape, shapes) →
      Cons(shape, zipW (fun (x, shape) → put_x x shape) (tail (iterate (length shapes + 1) (fun x → x + sep) (get_x shape))) shapes)
in
let width = 6 in
let sep = width + 1 in
let rects = map (fun (year, age) → Rect(0, 0, width, age)) data in
let rects' = spaceRight' sep rect_get_x rect_put_x rects in
let axis = fun margin n width →
   let tick = Cons(Point(0, 0), Cons(Point(0, -2), Nil)) in
   let ticks = fun n → 
      spaceRight width
         (fun x' → map (point_put_x x'))
         (repeat n tick)
   in
   let line = Cons(Point(0, 0), Cons(Point(n * width, 0), Nil)) in
   map (map (translate (0, 0 - margin))) Cons(line, ticks n)
in
let rectPath = fun Rect(x, y, w, h) →
   Cons(Point(x, y),
   Cons(Point(x + w, y),
   Cons(Point(x + w, y + h),
   Cons(Point(x, y + h), Nil))))
in
letrec 
   fun renderRects {
      Nil → Nil;
      Cons(r, rs) → match r as Rect(x, y, w, h) →
         let ps = rectPath r in
         Cons(PathStroke(Cons(Point(x, y + h), ps)), Cons(RectFill(ps), renderRects(rs)))
   }
in
   // required to be List<GraphicsElement>
   Cons(
      PathStroke(axis 1 5 7),
      Cons(
         PathStroke(map (map transpose) (axis 1 (length rects') width)),
         renderRects rects'
      )
   )
