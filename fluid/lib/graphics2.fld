// Simplistic but something more general may require primitives which take data values as inputs.
// Application module GraphicsRenderer must be loaded for these definitions to work.
// Str → Num
primitive textWidth;

// Str → Num
primitive textHeight;

// Want some kind of typeclass mechanism plus record accessors/updaters.
// Num → GraphicsElement → GraphicsElement
let set_x = fun x {
   Rect(_, y, w, h, fill) → Rect(x, y, w, h, fill);
   Group(_, y, w, h, scale, translate, gs) → Group(x, y, w, h, scale, translate, gs)
};

// ((Num, Num), (Num, Num)) → (Num, Num)
let dimensions2 = fun ((x1, y1), (x2, y2)) →
   (max2 (x1, x2), max2 (y1, y2));

// GraphicsElement → (Num, Num)
let dimensions = fun {
   Rect(_, _, w, h, _) → (w, h);
   Group(_, _, w, h, _, _, _) → (w, h);
   Polyline(Scale(x_scale, y_scale), ps, _, _, _) →
      match foldl boundingRect2 (0, 0) ps as
      (w, h) → (w * x_scale, h * y_scale)
};

// GraphicsElement → Num
let width = compose fst dimensions;

// GraphicsElement → Num
let height = compose snd dimensions;

// Num → Num → List GraphicsElement → List GraphicsElement
let spaceRight = fun z sep gs →
   zipWith (uncurry set_x) (iterate (length gs) (fun x → x + sep) z) gs;

// Bake colour decisions into the library for the time being. Provide two palettes, so we can have two
// different sets of categorical values (e.g. countries and energy types). Palettes from colorbrewer2.org.
let colours1 = ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"];
let colours2 = ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf"];

// Compositionality principle: child coords/dimensions are always expressed directly using parent reference 
// frame, to avoid depending on content of child, and so are not themselves scaled.
// Num → GraphicsElement → GraphicsElement
let scaleToWidth = fun w {
   Rect(x, y, _, h, fill) → Rect(x, y, w, h, fill);
   Group(x, y, w0, h, Scale(x_scale, y_scale), translate, gs) → 
      let scale = Scale(x_scale * w / w0, y_scale) in Group(x, y, w, h, scale, translate, gs);
   // polyline has an implicit coordinate of (0, 0), relative to which its points are located
   Polyline(Scale(x_scale, y_scale), ps, stroke, strokeWidth, marker) → 
      let scale = Scale(x_scale * w / max (map fst ps), y_scale) in 
      Polyline(scale, ps, stroke, strokeWidth, marker)
};

// List GraphicsElement → Num → GraphicsElement
let stackRight = fun sep gs →
   let gs' = map (scaleToWidth (1 - sep)) (spaceRight (sep / 2) 1 gs) in
   Group(0, 0, length gs, max (map height gs), Scale(1, 1), Translate(0, 0), gs');

// Num → List Str → List (a, Num) → GraphicsElement
let barChart = fun sep colours →
   compose 
      (stackRight sep)
      ((zipWith (fun (colour, (_, n)) → Rect(0, 0, 1, n, colour))) colours);

// First component of data (categorical value) currently ignored; values just mapped positionally to colors.
// List Str → List (a, Num) → GraphicsElement
let stackedBar = fun colours ns →
   let subtotals = scanl1 (fun (x, y) → x + y) 0 (map snd ns);
   let dims = zip [0, ...subtotals] (map (fun (x, y) → y - x) (zip [0, ...subtotals] subtotals));
   let rects = map 
      (fun ((y, height), colour) → Rect(0, y, 1, height, colour))
      (zip dims colours)
   in Group(0, 0, 1, last subtotals, Scale(1, 1), Translate(0, 0), rects);

// Heuristic saying how often to place a tick on an axis of length n.
// Num → Num
let tickEvery = fun n →
   let m = floor (logBase 10 n) in
   match n <= 2 * 10 ** m as {
      True → 2 * 10 ** (m - 1);
      False → 10 ** m
   };

// Bool → Str → Num → Num → GraphicsElement 
let axis = fun vert colour x start end →
   let tickSp = tickEvery (end - start);
   let firstTick = ceilingToNearest start tickSp;
   let n = floor ((end - firstTick) / tickSp) + 1;
   let ys = concat (iterate n (fun y → y + tickSp) firstTick) [end];
   // avoid redundant start point; not so easy/efficient for end point, so don't bother
   let ys = match firstTick > start as {
      True → [start, ...ys];
      False → ys
   };
   let mkPoint = match vert as {
      True → fun y → (x, y);
      False → fun y → (y, x)
   };
   let tick = match vert as { True → LeftTick; False → RightTick }
   in Polyline(Scale(1, 1), map mkPoint ys, colour, 0.25, Some(tick));

// Str → Num → Num → GraphicsElement 
let x_axis = axis False;
let y_axis = axis True;

// Worry about dimensions of margin later. Only defined for Group for now.
// GraphicsElement → GraphicsElement
let background = 
   let m = 1.5 in // relative to parent coordinate frame
   fun Group(x, y, w, h, Scale(x_scale, y_scale), Translate(dx, dy), gs) →
      let x_scale' = x_scale * max2 (w - 2 * m, 0) / w;
      let y_scale' = y_scale * max2 (h - 2 * m, 0) / h;
      let translate = Translate(debugLog dx + m / debugLog x_scale', dy + m * y_scale');
      let gs = [Rect(x, y, w, h, "white"), Group(x, y, w, h, Scale(x_scale', y_scale'), translate, gs)]
      in Group(0, 0, x + w, y + h, Scale(1, 1), Translate(0, 0), gs);

// Plot a subset of the categories from a map of x values to (categorical value, y value) pairs.
// List Str → List k2 → List (Num, List (k2, Num)) → GraphicsElement
let multiPlot = fun withAxes colours x_start ks data →
   let xs = map fst data;
   // Str → Str → (GraphicsElement, Num)
   let plot = fun k colour →
      let ps = map (second (lookup k)) data in
      (Polyline(Scale(1, 1), ps, colour, 1, Some(Circle)), max (map snd ps));
   let lines = zipWith (uncurry plot) ks colours;
   let x_finish = last xs;
   let y_finish = max (map snd lines);
   let gs = map fst lines;
   let axes = match withAxes as {
      True → [x_axis "black" 0 x_start x_finish, y_axis "black" x_start 0 y_finish];
      False → []
   }
   in background
      Group(0, 0, x_finish - x_start, y_finish, Scale(1, 1), Translate(0 - x_start, 0), concat gs axes);

// See stackedBar for strong (unjustified) assumption about uniformity of data.
// Num → List (List (a, Num)) → GraphicsElement
let stackedBarChart = fun sep →
   compose (stackRight sep) (map (stackedBar colours1))
