// Want some kind of typeclass mechanism plus record accessors/updaters.
let coords = fun {
   Rect(x, y, _, _, _, _) → (x, y);
   Group(x, y, _, _, _, _) → (x, y)
};

// Num → GraphicsElement → GraphicsElement
let x_translate = fun dx g → 
   match coords g as (x, y) → set_x g (x + dx);

// Num → GraphicsElement → GraphicsElement
let set_x = fun x {
   Rect(_, y, w, h, scale, fill) → Rect(x, y, w, h, scale, fill);
   Group(_, y, w, h, scale, gs) → Group(x, y, w, h, scale, gs)
};

let get_scale = fun {
   Rect(_, _, _, _, scale, _) → scale;
   Group(_, _, _, _, scale, _) → scale
};

// Num → Num → Option Scale → Option Scale
let scaleByOpt = fun x1 y1 {
   None → Some(Scale(x1, y1));
   Some(Scale(x2, y2)) → Some(Scale(x1 * x2, y1 * y2))
};

// Num → Num → GraphicsElement → GraphicsElement
let scaleBy = fun x1 y1 {
   Rect(x, y, w, h, scale, fill) → Rect(x, y, w, h, scaleByOpt x1 y1 scale, fill);
   Group(x, y, w, h, scale, gs) → Group(x, y, w, h, scaleByOpt x1 y1 scale, gs)
};

// GraphicsElement → Num
let get_x = compose fst coords;

// GraphicsElement → Num
let get_y = compose snd coords;

// GraphicsElement → (Num, Num)
let dimensions = fun {
   Rect(_, _, w, h, _, _) → (w, h);
   Group(_, _, w, h, _, _) → (w, h)
};

// GraphicsElement → Num
let width = compose fst dimensions;

let set_width = fun w {
   Rect(x, y, _, h, scale, fill) → Rect(x, y, w, h, scale, fill);
   Group(x, y, _, h, scale, gs) → Group(x, y, w, h, scale, gs)
};

// GraphicsElement → Num
let height = compose snd dimensions;

// Num → Num → List GraphicsElement → List GraphicsElement
let spaceRight = fun z sep gs →
   zipW (uncurry set_x) (iterate (length gs) (fun x → x + sep) z) gs;

// Bake colour decisions into the library for the time being.
// List Str
let colours = [
   "RosyBrown",
   "HotPink",
   "PaleGreen",
   "Aquamarine",
   "Plum",
   "LightCoral",
   "Navy"
];

// Compositionality principle: child coords/dimensions are always expressed directly using the parent's reference 
// frame, to avoid having them depend on the content of the child.
// Num → GraphicsElement → GraphicsElement
let scaleToWidth = fun n g →
   set_width n (scaleBy (n / width g) 1 g);

// List GraphicsElement → Num → GraphicsElement
let stackRight = fun sep gs →
   Group(0, 0, length gs, max (map height gs), None, map (scaleToWidth (1 - sep)) (spaceRight (sep / 2) 1 gs));

// Num → List (a, Num) → GraphicsElement
let barChart = fun sep →
   compose 
      (stackRight sep)
      ((zipW (fun (col, (_, n)) → Rect(0, 0, 1, n, None, col))) colours);

// List (a, Num) → GraphicsElement
let stackedBar = fun ns →
   let subtotals = scanl1 (fun (x, y) → x + y) 0 (map snd ns);
   let dims = zip [0, ...subtotals] (map (fun (x, y) → y - x) (zip [0, ...subtotals] subtotals));
   let rects = map 
      (fun ((y, height), col) → Rect(0, y, 1, height, None, col))
      (zip dims colours)
   in Group(0, 0, 1, last subtotals, None, rects)
