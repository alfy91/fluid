// Want some kind of typeclass mechanism plus record accessors/updaters.
let coords = fun {
   Rect(x, y, _, _, _, _) → (x, y);
   Group(x, y, _, _, _, _) → (x, y)
};

// Num → GraphicsElement → GraphicsElement
let x_translate = fun dx g → 
   match coords g as (x, y) → set_x g (x + dx);

// Num → GraphicsElement → GraphicsElement
let set_x = fun x {
   Rect(_, y, w, h, scale, fill) → Rect(x, y, w, h, scale, fill);
   Group(_, y, w, h, scale, gs) → Group(x, y, w, h, scale, gs)
};

// Scale → GraphicsElement → GraphicsElement
let set_scale = fun scale {
   Rect(x, y, w, h, _, fill) → Rect(x, y, w, h, Some(scale), fill);
   Group(x, y, w, h, _, gs) → Group(x, y, w, h, Some(scale), gs)
};

// GraphicsElement → Num
let get_x = compose fst coords;

// GraphicsElement → Num
let get_y = compose snd coords;

// GraphicsElement → (Num, Num)
let dimensions = fun {
   Rect(_, _, w, h, _, _) → (w, h);
   Group(_, _, w, h, _, _) → (w, h)
};

// GraphicsElement → Num
let width = compose fst dimensions;

// GraphicsElement → Num
let height = compose snd dimensions;

// Num → List GraphicsElement → List GraphicsElement
let spaceRight = fun sep gs →
   zipW (uncurry set_x) (iterate (length gs) (fun x → x + sep) 0) gs;

// Bake colour decisions into the library for the time being.
// List Str
let colours = [
   "RosyBrown",
   "HotPink",
   "PaleGreen",
   "Aquamarine",
   "Plum",
   "LightCoral",
   "Navy"
];

// Num → GraphicsElement → GraphicsElement
let scaleToWidth = fun n g → 
   set_scale (Scale(n / width g, 1)) g;

// List (a, Num) → GraphicsElement
let barChart = 
   let makeBar = fun ((_, n), col) → 
      Rect(0, 0, 1, n, None, col) in
   fun data →
      let rects = zipW makeBar data colours in
      Group(0, 0, length rects, max (map height rects), None, spaceRight 1 rects)
