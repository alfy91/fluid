// Simplistic but something more general may require primitives which take data values as inputs.
// Application module GraphicsRenderer must be loaded for these definitions to work.
// Str → Num
primitive textWidth;

// Str → Num
primitive textHeight;

// Want some kind of typeclass mechanism plus record accessors/updaters.
// Num → GraphicsElement → GraphicsElement
letrec fun set_x x {
   Rect(_, y, w, h, fill) → Rect(x, y, w, h, fill);
   Viewport(_, y, w, h, scale, translate, gs) → Viewport(x, y, w, h, scale, translate, gs);
   Group(gs) → Group(map (set_x x) gs)
};

// ((Num, Num), (Num, Num)) → (Num, Num)
let dimensions2 = fun ((x1, y1), (x2, y2)) →
   (max2 (x1, x2), max2 (y1, y2));

// GraphicsElement → (Num, Num)
letrec fun dimensions {
   Rect(_, _, w, h, _) → (w, h);
   Viewport(_, _, w, h, _, _, _) → (w, h);
   Group(gs) → match unzip (map dimensions gs) as (ws, hs) → (max ws, max hs);
   Polyline(ps, _, _, _) → foldl dimensions2 (0, 0) ps
};

// GraphicsElement → Num
let width = compose fst dimensions;

// GraphicsElement → Num
let height = compose snd dimensions;

// Num → Num → List GraphicsElement → List GraphicsElement
let spaceRight = fun z sep gs →
   zipWith (uncurry set_x) (iterate (length gs) (fun x → x + sep) z) gs;

// Bake colour decisions into the library for the time being. Provide two palettes, so we can have two
// different sets of categorical values (e.g. countries and energy types). Palettes from colorbrewer2.org.
let colours1 = ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"];
let colours2 = ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf"];

// Compositionality principle: child coords/dimensions are always expressed directly using parent reference 
// frame, to avoid depending on content of child, and so are not themselves scaled. Polyline can't be scaled
// directly because it inherits its frame of reference from its parent.
// Num → GraphicsElement → GraphicsElement
letrec fun scaleToWidth w {
   Rect(x, y, _, h, fill) → Rect(x, y, w, h, fill);
   Viewport(x, y, w0, h, Scale(x_scale, y_scale), translate, gs) → 
      let scale = Scale(x_scale * w / w0, y_scale) in Viewport(x, y, w, h, scale, translate, gs);
   Group(gs) → Group(map (scaleToWidth w) gs)
};

// Num → List GraphicsElement → List GraphicsElement
let stackRight = fun sep gs →
   map (scaleToWidth (1 - sep)) (spaceRight (sep / 2) 1 gs);

// Num → List GraphicsElement → GraphicsElement
let groupRight = fun sep gs →
   Viewport(0, 0, length gs, max (map height gs), Scale(1, 1), Translate(0, 0), stackRight sep gs);

// Heuristic saying how often to place a tick on an axis of length n.
// Num → Num
let tickEvery = fun n →
   let m = floor (logBase 10 n) in
   match n <= 2 * 10 ** m as {
      True → 2 * 10 ** (m - 1);
      False → 10 ** m
   };

let axisStrokeWidth = 0.5;
let tickLength = 0.1;

// Str → Num → GraphicsElement
let leftTick = fun colour str len →
   let tick = Line((0, 0), (0 - len, 0), colour, axisStrokeWidth)
   in Group([tick, Text(0 - len, 0, str, "end", "central")]);

let downTick = fun colour str len →
   let tick = Line((0, 0), (0, 0 - len), colour, axisStrokeWidth)
   in Group([tick, Text(0, 0 - len, str, "middle", "hanging")]);

// Notionally a y-axis located at position x on the x-axis.
// Bool → Str → Num → Num → GraphicsElement 
let axis = fun vert colour x start end →
   let tickSp = tickEvery (end - start);
   let firstTick = ceilingToNearest start tickSp;
   let n = floor ((end - firstTick) / tickSp) + 1;
   let ys = concat (iterate n (fun y → y + tickSp) firstTick) [end];
   // avoid redundant start point; not so easy/efficient for end point, so don't bother
   let ys = match firstTick > start as {
      True → [start, ...ys];
      False → ys
   };
   let mkPoint = match vert as {
      True → fun y → (x, y);
      False → fun y → (y, x)
   };
   let makeTick = match vert as { True → leftTick colour; False → downTick colour };
   let ps = map mkPoint ys
   in Group([
      Line(head ps, last ps, colour, axisStrokeWidth),
      Polymarkers(ps, flip map ys (compose (flip makeTick tickLength) numToStr))
   ]);

// Str → Num → Num → GraphicsElement 
let x_axis = axis False;
let y_axis = axis True;

// Only defined for Group for now. Margin size is relative to parent coordinate frame.
// Num → GraphicsElement → GraphicsElement
let background = fun m Viewport(x, y, w, h, Scale(x_scale, y_scale), Translate(dx, dy), gs) →
   // should detect division by zero here
   let x_scale' = x_scale * max2 (w - 2 * m, 0) / w;
   let y_scale' = y_scale * max2 (h - 2 * m, 0) / h;
   let translate = Translate(dx + m / x_scale', dy + m / y_scale')
   in Group([Rect(x, y, w, h, "Gainsboro"), Viewport(x, y, w, h, Scale(x_scale', y_scale'), translate, gs)]);
   
// Plot a subset of the categories from a map of x values to (categorical value, y value) pairs.
// Bool → List Str → List k2 → List (Num, List (k2, Num)) → GraphicsElement
let lineChart = fun withAxes colours x_start ks data →
   let xs = map fst data;
   // Str → Str → (GraphicsElement, Num)
   let plot = fun k colour →
      let ps = map (second (lookup k)) data in
      (Polyline(ps, colour, 1, Some(Circle)), max (map snd ps));
   let lines = zipWith (uncurry plot) ks colours;
   let x_finish = last xs;
   let y_finish = max (map snd lines);
   let gs = map fst lines;
   let axes = match withAxes as {
      True → [x_axis "black" 0 x_start x_finish, y_axis "black" x_start 0 y_finish];
      False → []
   }
   in background 0.7
      Viewport(0, 0, x_finish - x_start, y_finish, Scale(1, 1), Translate(0 - x_start, 0), concat gs axes);

// (List Str → List a → GraphicsElement) → Bool → List Str → Num → List (b, a) → GraphicsElement
let chart = fun mkChart withAxes colours sep data →
   let gs = stackRight sep (mkChart colours (map snd data));
   let w = length gs;
   let h = max (map height gs);
   let axes = match withAxes as {
      True → [x_axis "black" 10 0 w, y_axis "black" 0 0 h];
      False → []
   }
   in background 0.2
      Viewport(0, 0, w, h, Scale(1, 1), Translate(0, 0), concat gs axes);

// List Str → List a → GraphicsElement
let rects = fun colours ns →
   zipWith (fun (colour, n) → Rect(0, 0, 1, n, colour)) colours ns;

// First component of data (categorical value) currently ignored; values just mapped positionally to colors.
// List Str → List (a, Num) → GraphicsElement
let stackedBar = fun colours ns →
   let subtotals = scanl1 (fun (x, y) → x + y) 0 (map snd ns);
   let dims = zip [0, ...subtotals] (map (fun (x, y) → y - x) (zip [0, ...subtotals] subtotals));
   let rects = map 
      (fun ((y, height), colour) → Rect(0, y, 1, height, colour))
      (zip dims colours)
   in Viewport(0, 0, 1, last subtotals, Scale(1, 1), Translate(0, 0), rects);

// Bool → List Str → Num → List (a, Num) → GraphicsElement
let barChart = chart rects;

// For each categorical value of type a, plot a bar chart for the corresponding b-indexed data.
// Bool → List Str → Num → List (a, List (b, Num)) → GraphicsElement
let groupedBarChart = chart (compose map (flip (barChart False) 0));

// See stackedBar for strong (unjustified) assumption about uniformity of data.
// Bool → List Str → Num → List (a, List (b, Num)) → GraphicsElement
let stackedBarChart = chart (compose map stackedBar)
