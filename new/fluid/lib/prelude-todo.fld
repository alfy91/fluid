-- Num -> Num
primitive ceiling;

-- Str -> a
primitive error;

-- Num -> Num
primitive floor;

-- Natural logarithm.
-- Num -> Num
primitive log;

-- Num -> Str
primitive numToStr;

-- Print argument to the console and return it.
-- a -> a
primitive debugLog;

-- Log of x in base y.
-- Num -> Num -> Num
let logBase x y = log y / log x;

-- List a -> a -> List a
let intersperse {
   Nil sep -> Nil;
   (Cons x Nil) sep -> Cons x Nil;
   (Cons x (Cons y ys)) sep -> Cons x (Cons sep (intersperse (Cons y ys)))
};

-- Num -> (a -> a) -> a -> List a
let iterate n f z =
   if n == 0
   then []
   else z : map f (iterate (n - 1) f z);

-- Num -> Num
let negate = (-) 0;

-- Num -> a -> List a
let repeat = flip iterate id;

-- a -> List (a, b) -> b (where a âˆˆ {Num, Str})
let lookup k ((k', v) : kvs) ->
   if k == k' then v else lookup k kvs;

-- (Num, Num) -> Num
let max2 (n, m) =
   if n > m then n else m;

-- (Num, Num) -> Num
let min2 (n, m) =
   if n < m then n else m;

-- List Num -> Num
let max = foldr1 max2;

-- List Num -> Num
let min = foldr1 min2;

-- Expects non-negative integer as first argument and non-empty list as second argument.
-- Num -> List a -> a
let nth n (x : xs) ->
   if n == 0 then x else nth (n - 1) xs;

-- Num -> Num -> Num
let ceilingToNearest n m =
   ceiling (n / m) * m;

-- Num -> List a -> List a
let take n xs =
   if n <= 0
   then []
   else match xs as {
      [] -> [];
      x : xs -> x : take (n - 1) xs
   };

-- Num -> List a -> List a
let drop n xs =
   if n <= 0
   then xs
   else match xs as {
      [] -> [];
      _ : xs -> drop (n - 1) xs
   };

-- Num -> List a -> List a
let lastN n xs =
   foldl (uncurry (compose const (drop 1))) xs (drop n xs);
