-- typedef Colour = Str
-- typedef Colours = List Colour
-- typedef Cat = Str

-- Group has location (0, 0) because it doesn't interfere with positioning of its children.
-- GraphicsElement -> Point
let coords (Group gs) = Point 0 0;
    coords (Rect x y _ _ _) = Point x y;
    coords (Text x y _ _ _) = Point x y;
    coords (Viewport x y _ _ _ _ _ _ _) = Point x y;

-- GraphicsElement -> Float
let get_x g = let Point x _ = coords g in x;

-- GraphicsElement -> Float
let get_y g = let Point _ y = coords g in x;

-- Want some kind of typeclass mechanism plus record accessors/updaters.
-- Float -> GraphicsElement -> GraphicsElement
let set_x x (Group gs) = error "Group has immutable coordinates";
    set_x x (Rect _ y w h fill) = Rect x y w h fill;
    set_x x (Text _ y str anchor baseline) = Text x y str anchor baseline;
    set_x x (Viewport _ y w h fill margin scale translate g) = Viewport x y w h fill margin scale translate g;

-- (Point, Point) -> Point
let dimensions2 (Point x1 y1, Point x2 y2) = Point (max2 (x1, x2)) (max2 (y1, y2));

-- For Group, dimensions are relative to implicit coords of (0, 0), since a Group's children are effectively
-- positioned relative to parent of Group. For Polymarker, will probably have to ignore the markers themselves,
-- since they are scale-invariant.
-- GraphicsElement -> Point
let
   dimensions (Group gs) = foldl dimensions2 (Point 0 0) (map (coords_op) gs);
   dimensions (Polyline ps _ _) = foldl dimensions2 (Point 0 0) ps;
   dimensions (Rect _ _ w h _) = Point w h;
   dimensions (Text _ _ _ _ _) = Point 0 0; -- treat text like markers; scale-invariant
   dimensions (Viewport _ _ w h _ _ _ _ _) = Point w h;

   coords_op g =
      let (Point x y, Point w h) = prod coords dimensions g in
      Point (x + w) (y + h);

-- GraphicsElement -> Float
let width g = let Point w _ = dimensions g in w;

-- GraphicsElement -> Float
let height g = let Point _ h = dimensions g in h;

-- Float -> Float -> List GraphicsElement -> List GraphicsElement
let spaceRight z sep gs =
   zipWith (uncurry set_x) (iterate (length gs) ((+) sep) z) gs;

-- Bake colour decisions into the library for the time being. Provide two palettes, so we can have two
-- different sets of categorical values (e.g. countries and energy types). Palettes from colorbrewer2.org.
let colours1 = "#66c2a5" : "#a6d854" : "#ffd92f" : "#e5c494" : "#fc8d62" : "#b3b3b3" : "#8da0cb" : "#e78ac3" : Nil;
let colours2 = "#e41a1c" : "#377eb8" : "#4daf4a" : "#984ea3" : "#ff7f00" : "#ffff33" : "#a65628" : "#f781bf" : Nil;

-- Compositionality principle: child coords/dimensions are always expressed directly using parent reference
-- frame, to avoid depending on content of child, and so are not themselves scaled. Polyline can't be scaled
-- directly because it inherits its frame of reference from its parent. For Viewport, margin will shrink the
-- available area, possibly to zero, at which point nothing will be rendered.
-- Float -> GraphicsElement -> GraphicsElement
let scaleToWidth w (Rect x y _ h fill) = Rect x y w h fill;
    scaleToWidth w (Viewport x y w0 h fill margin (Scale x_scale y_scale) translate g) =
      let scale = Scale (x_scale * w / w0) y_scale in
      Viewport x y w h fill margin scale translate g;

-- Float -> List GraphicsElement -> List GraphicsElement
let stackRight sep gs =
   map (scaleToWidth (1 - sep)) (spaceRight (sep / 2) 1 gs);

-- Float -> List GraphicsElement -> GraphicsElement
let groupRight sep gs =
   Viewport 0 0 (length gs) (max (map height gs)) "none" 0 (Scale 1 1) (Translate 0 0) (Group (stackRight sep gs));

-- Heuristic saying how often to place a tick on an axis of length n.
-- Float -> Float
let tickEvery n =
   let m = floor (logBase 10 n) in
   match n <= 2 * 10 ** m as {
      True -> 2 * 10 ** (m - 1);
      False -> 10 ** m
   };

let axisStrokeWidth = 0.5;
    axisColour = "black";
    backgroundColour = "white";
    defaultMargin = 24;
    markerRadius = 3.5;
    tickLength = 4;

-- Helpers for axis functions.
-- Orient -> Colour -> Float -> GraphicsElement
let tick Horiz colour len = Line (Point 0 0) (Point 0 (0 - len)) colour axisStrokeWidth;
    tick Vert colour len = Line (Point 0 0) (Point (0 - len) 0) colour axisStrokeWidth;

-- Orient -> Float -> Float -> Str -> GraphicsElement
let label Horiz x distance str = Text x (0 - distance - 4) str "middle" "hanging";
    label Vert x distance str = Text (0 - distance) x str "end" "central";

-- Orient -> Colour -> Float -> Str -> GraphicsElement
let labelledTick orient colour len str =
   Group (tick orient colour len : label orient 0 len str : Nil);

-- Orient -> Float -> Float -> Point
let mkPoint Horiz x y = Point y x;
    mkPoint Vert x y = Point x y;

-- x is position of this axis on the other axis. Returns axis and position of last tick.
-- Orient -> Float -> Float -> Float -> GraphicsElement
let axis orient x start end =
   let tickSp = tickEvery (end - start);
       firstTick = ceilingToNearest start tickSp;
       lastTick = ceilingToNearest end tickSp;
       n = floor ((end - firstTick) / tickSp) + 1;
       ys = iterate n ((+) tickSp) firstTick;
       -- avoid redundant start and end points
       ys = match firstTick > start as {
          True -> start : ys;
          False -> ys
       };
       ys = match lastTick > end as {
          True -> concat2 ys (lastTick : Nil);
          False -> ys
       };
       ps = map (mkPoint orient x) ys;
       ax = Group (
          Line (head ps) (last ps) axisColour axisStrokeWidth :
          Polymarkers ps (flip map ys (compose (labelledTick orient axisColour tickLength) numToStr)) :
          Nil
       )
   in (ax, lastTick);

-- x is position of this axis on the other axis.
-- Orient -> Float -> List Cat -> GraphicsElement
let catAxis orient x catValues =
   let ys = iterate (length catValues + 1) ((+) 1) 0;
       ps = map (mkPoint orient x) ys
   in Group (
      Line (head ps) (last ps) axisColour axisStrokeWidth :
      Polymarkers (tail ps) (map (const (tick orient axisColour tickLength)) catValues) :
      Polymarkers (flip map (tail ps) (fun (Point x y) -> Point (x - 0.5) y)) (map (label orient -0.5 0) catValues) :
      Nil
   );

-- Float -> Float -> Float -> Float -> List GraphicsElement -> GraphicsElement
let viewport x_start x_finish y_finish margin gs =
   Viewport 0 0 (x_finish - x_start) y_finish backgroundColour margin
            (Scale 1 1) (Translate (0 - x_start) 0) (Group gs);
