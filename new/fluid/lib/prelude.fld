-- (b -> c) -> (a -> b) -> a -> c
-- Want infix <<<
let compose f g x = f (g x);

-- (a, b) -> c) -> a -> b -> c
let curry f x y = f (x, y);

-- (a -> b -> c) -> (a, b) -> c
let uncurry f (x, y) = f x y;

-- (a -> b) -> (a, c) -> (b, c)
let first f (a, c) = (f a, c);

-- (a, b) -> b
let snd (x, y) = y;

-- (a -> b) -> (c, a) -> (c, b)
let second f (c, a) = (c, f a);

-- (a -> b -> c) -> b -> a -> c
let flip f x y = f y x;

-- (a, b) -> a
let fst (x, y) = x;

-- a -> a
let id x = x;

-- (a -> b) -> (a -> c) -> a -> (b, c)
-- Want infix &&&
let prod f g x = (f x, g x);

-- (a, b) -> (b, a)
let swap (a, b) = (b, a);

-- List a -> a
let head (Cons x xs) = x;

-- List a -> List a -> List a
let concat {
   Nil ys -> ys;
   (Cons x xs) ys -> Cons x (concat xs ys)
};

-- ((a, b) -> a) -> a -> List b -> a
let foldl op z {
   Nil -> z;
   Cons x xs -> foldl op (op (z, x)) xs
};

-- ((a, b) -> a) -> List b -> a
let foldl1 op {
   Cons x xs -> foldl op x xs
};

-- ((a, b) -> b) -> b -> List a -> b
let foldr op z {
   Nil -> z;
   Cons x xs -> op (x, foldr op z xs)
};

-- ((a, b) -> b) -> List a -> b
let foldr1 op {
   Cons x Nil -> x;
   Cons x (Cons y xs) -> op (x, foldr1 op (Cons y xs))
};

-- ((a, b) -> a) -> a -> List b -> List a
let scanl1 op z xs =
   let go (x, continue) acc =
      let next = op (acc, x);
      Cons next (continue next);
   foldr go (const Nil) xs z;

-- ((a, b) -> a) -> a -> List b -> List a
let scanl op z xs =
   Cons z (scanl1 op z xs);

-- List a -> a
let last {
   Cons x Nil -> x;
   Cons x (Cons y ys) -> last (Cons y ys)
};
