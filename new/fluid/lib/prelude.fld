// Num → Num
primitive ceiling;

// Str → a
primitive error;

// Num → Num
primitive floor;

// Natural logarithm.
// Num → Num
primitive log;

// Num → Str
primitive numToStr;

// Print argument to the console and return it.
// a → a
primitive debugLog;

// Bool → Bool
fun or x y = if x then True else y;

// Bool → Bool
fun not x = if x then False else True;

// (b → c) → (a → b) → a → c
// Would like infix operators.
fun compose f g x = f (g x);

// a → b → a
fun const x _ = x;

// (a → b) → (a, c) → (b, c)
fun first f (a, c) = (f a, c);

// (a, b) → a
fun fst (x, y) = x;

// List a → a
fun head [x, ...xs] = x;

// a → a
fun id x = x;

// (a → b) → (a → c) → a → (b, c)
fun prod f g x = (f x, g x);

// Num → Num → Ordering
fun compare (x, y) =
   if x < y
   then LT
   else if x > y
      then GT
      else EQ;

// List a → List a → List a
fun concat {
   [] ys → ys;
   [x, ...xs] ys → [x, ...concat xs ys]
};

// a → List a → Bool (where a ∈ {Num, Str})
fun elem x {
   [] → False;
   [x', ...xs] → or (x == x') (elem x xs)
};

// (a → Bool) → List a → List a
fun filter p {
   [] → [];
   [x, ...xs] →
      let ys = filter p xs;
      if p x then [x, ...ys] else ys
};

// (a → b → c) → b → a → c
fun flip f x y = f y x;

// ((a, b) → a) → a → List b → a
fun foldl op z {
   [] → z;
   [x, ...xs] → foldl op (op (z, x)) xs
};

// ((a, b) → a) → List b → a
fun foldl1 op {
   [x, ...xs] → foldl op x xs
};

// ((a, b) → b) → b → List a → b
fun foldr op z {
   [] → z;
   [x, ...xs] → op (x, foldr op z xs)
};

// ((a, b) → b) → List a → b
fun foldr1 op {
   [x] → x;
   [x, y, ...xs] → op (x, foldr1 op [y, ...xs])
};

// ((a, b) → a) → a → List b -> List a
fun scanl1 op z xs =
   let go (x, continue) acc =
      let next = op (acc, x);
      [next, ...continue next];
   foldr go (const []) xs z;

// ((a, b) → a) → a → List b -> List a
fun scanl op z xs =
   [z, ...scanl1 op z xs];

// List a → a → List a
fun intersperse {
   [] sep → [];
   [x] sep → [x];
   [x, y, ...ys] sep → [x, sep, ...intersperse [y, ...ys]]
};

// List a → a
fun last {
   [x] → x;
   [x, y, ...xs] → last [y, ...xs]
};

// Log of x in base y.
// Num → Num → Num
fun logBase x y = log y / log x;

// (a → b) → List a → List b
fun map f {
   [] → [];
   [x, ...xs] → [f x, ...map f xs]
};

// Num → (a → a) → a → List a
fun iterate n f z =
   if n == 0
   then []
   else [z, ...map f (iterate (n - 1) f z)];

// List a → Num
fun length {
   [] → 0;
   [x, ...xs] → 1 + length xs
};

// Num → Num
let negate = (-) 0;

// List a → List a
fun reverse {
   [] → [];
   [x, ...xs] → concat (reverse xs) [x]
};

// List (a, b) → (List a, List b)
fun unzip {
   [] → ([], []);
   [(x, y), ...xys] →
      let (xs, ys) = unzip xys;
      ([x, ...xs], [y, ...ys])
};

// ((a, b) → c) → List a → List b → List c
fun zipWith op {
   [] ys → [];
   [x, ...xs] {
      [] → [];
      [y, ...ys] → [op (x, y), ...zipWith op xs ys]
   }
};

let zip = zipWith id;

// Num → a → List a
let repeat = flip iterate id;

// a → List (a, b) → b (where a ∈ {Num, Str})
fun lookup k [(k', v), ...kvs] →
   if k == k' then v else lookup k kvs;

// (Num, Num) → Num
fun max2 (n, m) =
   if n > m then n else m;

// (Num, Num) → Num
fun min2 (n, m) =
   if n < m then n else m;

// List Num → Num
let max = foldr1 max2;

// List Num → Num
let min = foldr1 min2;

// Expects non-negative integer as first argument and non-empty list as second argument.
// Num → List a → a
fun nth n [x, ...xs] →
   if n == 0 then x else nth (n - 1) xs;

// Num → Num → Num
fun ceilingToNearest n m =
   ceiling (n / m) * m;

// (a → b) → (c, a) → (c, b)
fun second f (c, a) = (c, f a);

// (a, b) → b
fun snd (x, y) = y;

// List Num → Num
fun sum xs =
   foldr (fun (x, y) → x + y) 0 xs;

// (a, b) → (b, a)
fun swap (a, b) = (b, a);

// List a → List a
fun tail [x, ...xs] = xs;

// (a, b) → c) → a → b → c
fun curry f x y = f (x, y);

// (a → b → c) → (a, b) → c
fun uncurry f (x, y) = f x y;

fun take n xs =
   if n <= 0
   then []
   else match xs as {
      [] → [];
      [x, ...xs] → [x, ...take (n - 1) xs]
   };

fun drop n xs =
   if n <= 0
   then xs
   else match xs as {
      [] → [];
      [_, ...xs] → drop (n - 1) xs
   };

// Num → List a → List a
fun lastN n xs =
   foldl (uncurry (compose const (drop 1))) xs (drop n xs)
