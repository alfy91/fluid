-- "Num" throughout means (Int + Float).

-- Bool -> Bool
let and False y = False;
    and True y = y;

-- Bool -> Bool
let or True y = True;
    or False y = y;

-- Bool -> Bool
let not True = False;
    not False = True;

-- Int -> Int -> Ordering
let compare (x, y) =
   match x < y as {
      True -> LT;
      False -> match x > y as {
        True -> GT;
        False -> EQ
      }
   };

-- Num -> Num
let negate = (-) 0;

-- Log of x in base y.
-- Float -> Float -> Float
let logBase x y = log y / log x;

-- Float -> Float -> Float
let ceilingToNearest n m =
   ceiling (n / m) * m;

-- (b -> c) -> (a -> b) -> a -> c
-- Want infix <<<
let compose f g x = f (g x);

-- (a, b) -> c) -> a -> b -> c
let curry f x y = f (x, y);

-- (a -> b -> c) -> (a, b) -> c
let uncurry f (x, y) = f x y;

-- (a -> b) -> (a, c) -> (b, c)
let first f (a, c) = (f a, c);

-- (a, b) -> b
let snd (_, y) = y;

-- (a -> b) -> (c, a) -> (c, b)
let second f (c, a) = (c, f a);

-- (a -> b -> c) -> b -> a -> c
let flip f x y = f y x;

-- (a, b) -> a
let fst (x, _) = x;

-- a -> a
let id x = x;

-- (a -> b) -> (a -> c) -> a -> (b, c)
-- Want infix &&&
let prod f g x = (f x, g x);

-- (a, b) -> (b, a)
let swap (a, b) = (b, a);

-- List a -> a
let head (x : _) = x;

-- List a -> List a
let tail (_ : xs) = xs;

-- Int -> List Int -> Bool
let elem x Nil = False;
    elem x (x' : xs) = or (x == x') (elem x xs);

-- (a -> Bool) -> List a -> List a
let filter p Nil = Nil;
    filter p (x : xs) =
      let ys = filter p xs in
      match p x as {
          True -> x : ys;
          False -> ys
      };

-- Todo: have these take uncurried operators
-- ((a, b) -> a) -> a -> List b -> a
let foldl op z Nil = z;
    foldl op z (x : xs) = foldl op (op (z, x)) xs;

-- ((a, b) -> a) -> List b -> a
let foldl1 op (x : xs) = foldl op x xs;

-- ((a, b) -> b) -> b -> List a -> b
let foldr op z Nil = z;
    foldr op z (x : xs) = op (x, foldr op z xs);

-- ((a, b) -> b) -> List a -> b
let foldr1 op (x : Nil) = x;
    foldr1 op (x : y : xs) = op (x, foldr1 op (y : xs));

-- ((a, b) -> a) -> a -> List b -> List a
let scanl1 op z xs =
   let go (x, continue) acc =
      let next = op (acc, x) in
      next : continue next in
   foldr go (const Nil) xs z;

-- ((a, b) -> a) -> a -> List b -> List a
let scanl op z xs =
   z : scanl1 op z xs;

-- (a -> b) -> List a -> List b
let map f Nil = Nil;
    map f (x : xs) = f x : map f xs;

-- (List a, List a) -> List a
let append (Nil, ys) = ys;
    append ((x:xs), ys) = x : (append (xs, ys));

-- List a -> List -> List a
-- Want infix ++
let concat2 Nil ys = ys;
    concat2 (x : xs) ys = x : concat2 xs ys;

-- List (List a) -> List a
let concat = foldl (uncurry concat2) Nil;

-- List a -> a -> List a
let intersperse Nil sep = Nil;
    intersperse (x : Nil) sep = x : Nil;
    intersperse (x : y : ys) sep = x : sep : intersperse (y : ys);

-- Int -> (a -> a) -> a -> List a
let iterate n f z =
   match n == 0 as {
      True -> Nil;
      False -> z : map f (iterate (n - 1) f z)
   };

-- List Int -> Int
let sum xs =
   foldr (+) 0 xs;

-- List a -> a
let last (x : Nil) = x;
    last (x : y : ys) = last (y : ys);

-- List a -> Int
let length Nil = 0;
    length (_ : xs) = 1 + length xs;

-- List a -> List a
let reverse Nil = Nil;
    reverse (x : xs) = append ((reverse xs), (x : Nil));

-- Int -> a -> List a
let repeat = flip iterate id;

-- Int -> List a -> List a
let take n xs =
    match n <= 0 as {
       True -> Nil;
       False -> match xs as {
           Nil -> Nil;
           x : xs -> x : take (n - 1) xs
       }
    };

-- Int -> List a -> List a
let drop n xs =
   match n <= 0 as {
      True -> xs;
      False -> match xs as {
         Nil -> Nil;
         _ : xs -> drop (n - 1) xs
      }
   };

-- Int -> List a -> List a
let lastN n xs =
   foldl (uncurry (compose const (drop 1))) xs (drop n xs);

-- Expects non-negative integer as first argument and non-empty list as second argument.
-- Int -> List a -> a
let nth n (x : xs) =
   match n == 0 as {
      True -> x;
      False -> nth (n - 1) xs
   };

-- Int -> List (Int, b) -> b
let lookup k ((k', v) : kvs) =
   match k == k' as {
      True -> v;
      False -> lookup k kvs
   };

-- TODO: curry.
-- (Int, Int) -> Int
let max2 (n, m) =
   match n > m as {
      True -> n;
      False -> m
   };

-- (Int, Int) -> Int
let min2 (n, m) =
   match n < m as {
      True -> n;
      False -> m
   };

-- List Int -> Int
let max = foldr1 max2;

-- List Int -> Int
let min = foldr1 min2;

-- List (a, b) -> (List a, List b)
let unzip Nil = (Nil, Nil);
    unzip ((x, y) : zs) =
      let (xs, ys) = unzip zs in
      (x : xs, y : ys);

-- ((a, b) -> c) -> List a -> List b -> List c
let zipWith op Nil ys = Nil;
    zipWith op (x : xs) Nil = Nil;
    zipWith op (x : xs) (y : ys) = op (x, y) : zipWith op xs ys;

-- List a -> List b -> List (a, b)
let zip = zipWith id;

-- Int -> Int -> List Int
let range n m =
    match n <= m as {
       True  -> n : range (n + 1) m;
       False -> Nil
    };
