-- (b -> c) -> (a -> b) -> a -> c
-- Want infix <<<
let compose f g x = f (g x);

-- (a, b) -> c) -> a -> b -> c
let curry f x y = f (x, y);

-- (a -> b -> c) -> (a, b) -> c
let uncurry f (x, y) = f x y;

-- (a -> b) -> (a, c) -> (b, c)
let first f (a, c) = (f a, c);

-- (a, b) -> b
let snd (x, y) = y;

-- (a -> b) -> (c, a) -> (c, b)
let second f (c, a) = (c, f a);

-- (a -> b -> c) -> b -> a -> c
let flip f x y = f y x;

-- (a, b) -> a
let fst (x, y) = x;

-- a -> a
let id x = x;

-- (a -> b) -> (a -> c) -> a -> (b, c)
-- Want infix &&&
let prod f g x = (f x, g x);

-- (a, b) -> (b, a)
let swap (a, b) = (b, a);

-- List a -> a
let head (Cons x xs) = x;

-- List a -> List a
let tail (Cons x xs) = xs;

-- List a -> List a -> List a
let concat Nil ys = ys;
    concat (Cons x xs) ys = Cons x (concat xs ys);

-- ((a, b) -> a) -> a -> List b -> a
let foldl op z Nil = z;
    foldl op z (Cons x xs) = foldl op (op (z, x)) xs;

-- ((a, b) -> a) -> List b -> a
let foldl1 op (Cons x xs) = foldl op x xs;

-- ((a, b) -> b) -> b -> List a -> b
let foldr op z Nil = z;
    foldr op z (Cons x xs) = op (x, foldr op z xs);

-- ((a, b) -> b) -> List a -> b
let foldr1 op (Cons x Nil) = x;
    foldr1 op (Cons x (Cons y xs)) = op (x, foldr1 op (Cons y xs));

-- ((a, b) -> a) -> a -> List b -> List a
let scanl1 op z xs =
   let go (x, continue) acc =
      let next = op (acc, x) in
      Cons next (continue next);
   foldr go (const Nil) xs z;

-- ((a, b) -> a) -> a -> List b -> List a
let scanl op z xs =
   Cons z (scanl1 op z xs);

-- (a -> b) -> List a -> List b
let map f Nil = Nil;
    map f (Cons x xs) = Cons (f x) (map f xs);

-- List Num -> Num
let sum xs =
   foldr (fun (x, y) -> x + y) 0 xs;

-- List a -> a
let last (Cons x Nil) = x;
    last (Cons x (Cons y ys)) = last (Cons y ys);

-- List a -> Num
let length Nil = 0;
    length (Cons x xs) = 1 + length xs;

-- List a -> List a
let reverse Nil = Nil;
    reverse (Cons x xs) = concat (reverse xs) (Cons x Nil);

-- List (a, b) -> (List a, List b)
let unzip Nil = (Nil, Nil);
    unzip (Cons (x, y)) xys =
      let (xs, ys) = unzip xys in
      (Cons x xs, Cons y ys);

-- ((a, b) -> c) -> List a -> List b -> List c
let zipWith op Nil ys = Nil;
    zipWith op (Cons x xs) Nil = Nil;
    zipWith op (Cons x xs) (Cons y ys) = Cons (op (x, y)) (zipWith op xs ys);

-- List a -> List b -> List (a, b)
let zip = zipWith id in
