-- Bool -> Bool
let and False y = False;
    and True y = y;

-- Bool -> Bool
let or True y = True;
    or False y = y;

-- Bool -> Bool
let not True = False;
    not False = True;

-- Int -> Int -> Ordering
let compare (x, y) =
   match x < y as {
      True -> LT;
      False -> match x > y as {
        True -> GT;
        False -> EQ
      }
   };

-- (b -> c) -> (a -> b) -> a -> c
-- Want infix <<<
let compose f g x = f (g x);

-- (a, b) -> c) -> a -> b -> c
let curry f x y = f (x, y);

-- (a -> b -> c) -> (a, b) -> c
let uncurry f (x, y) = f x y;

-- (a -> b) -> (a, c) -> (b, c)
let first f (a, c) = (f a, c);

-- (a, b) -> b
let snd (x, y) = y;

-- (a -> b) -> (c, a) -> (c, b)
let second f (c, a) = (c, f a);

-- (a -> b -> c) -> b -> a -> c
let flip f x y = f y x;

-- (a, b) -> a
let fst (x, y) = x;

-- a -> a
let id x = x;

-- (a -> b) -> (a -> c) -> a -> (b, c)
-- Want infix &&&
let prod f g x = (f x, g x);

-- (a, b) -> (b, a)
let swap (a, b) = (b, a);

-- List a -> a
let head (Cons x xs) = x;

-- List a -> List a
let tail (Cons x xs) = xs;

-- List a -> List a -> List a
let concat Nil ys = ys;
    concat (Cons x xs) ys = Cons x (concat xs ys);

-- Int -> List Int -> Bool
let elem x Nil = False;
    elem x (Cons x' xs) = or (x == x') (elem x xs);

-- (a -> Bool) -> List a -> List a
let filter p Nil = Nil;
    filter p (Cons x xs) =
      let ys = filter p xs in
      match p x as {
          True -> Cons x ys;
          False -> ys
      };

-- ((a, b) -> a) -> a -> List b -> a
let foldl op z Nil = z;
    foldl op z (Cons x xs) = foldl op (op (z, x)) xs;

-- ((a, b) -> a) -> List b -> a
let foldl1 op (Cons x xs) = foldl op x xs;

-- ((a, b) -> b) -> b -> List a -> b
let foldr op z Nil = z;
    foldr op z (Cons x xs) = op (x, foldr op z xs);

-- ((a, b) -> b) -> List a -> b
let foldr1 op (Cons x Nil) = x;
    foldr1 op (Cons x (Cons y xs)) = op (x, foldr1 op (Cons y xs));

-- ((a, b) -> a) -> a -> List b -> List a
let scanl1 op z xs =
   let go (x, continue) acc =
      let next = op (acc, x) in
      Cons next (continue next) in
   foldr go (const Nil) xs z;

-- ((a, b) -> a) -> a -> List b -> List a
let scanl op z xs =
   Cons z (scanl1 op z xs);

-- (a -> b) -> List a -> List b
let map f Nil = Nil;
    map f (Cons x xs) = Cons (f x) (map f xs);

-- List a -> a -> List a
let intersperse Nil sep = Nil;
    intersperse (Cons x Nil) sep = Cons x Nil;
    intersperse (Cons x (Cons y ys)) sep = Cons x (Cons sep (intersperse (Cons y ys)));

-- Int -> (a -> a) -> a -> List a
let iterate n f z =
   match n == 0 as {
      True -> Nil;
      False -> Cons z (map f (iterate (n - 1) f z))
   };

-- List Int -> Int
let sum xs =
   foldr (fun (x, y) -> x + y) 0 xs;

-- List a -> a
let last (Cons x Nil) = x;
    last (Cons x (Cons y ys)) = last (Cons y ys);

-- List a -> Int
let length Nil = 0;
    length (Cons x xs) = 1 + length xs;

-- List a -> List a
let reverse Nil = Nil;
    reverse (Cons x xs) = concat (reverse xs) (Cons x Nil);

-- Int -> a -> List a
let repeat = flip iterate id;

-- Int -> List (Int, b) -> b
let lookup k (Cons (k', v) kvs) =
   match k == k' as {
      True -> v;
      False -> lookup k kvs
   };

-- (Int, Int) -> Int
let max2 (n, m) =
   match n > m as {
      True -> n;
      False -> m
   };

-- (Int, Int) -> Int
let min2 (n, m) =
   match n < m as {
      True -> n;
      False -> m
   };

-- List Int -> Int
let max = foldr1 max2;

-- List Int -> Int
let min = foldr1 min2;

-- List (a, b) -> (List a, List b)
let unzip Nil = (Nil, Nil);
    unzip (Cons (x, y)) xys =
      let (xs, ys) = unzip xys in
      (Cons x xs, Cons y ys);

-- ((a, b) -> c) -> List a -> List b -> List c
let zipWith op Nil ys = Nil;
    zipWith op (Cons x xs) Nil = Nil;
    zipWith op (Cons x xs) (Cons y ys) = Cons (op (x, y)) (zipWith op xs ys);

-- List a -> List b -> List (a, b)
let zip = zipWith id;
