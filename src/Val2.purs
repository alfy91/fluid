module Val2 where

import Prelude hiding (absurd)
import Control.Apply (lift2)
import Data.List (List)
import Data.List.NonEmpty (NonEmptyList, cons, cons', head, singleton, tail)
import Data.Map (Map, filterKeys, keys, insert, lookup, pop, toUnfoldable, unionWith)
import Data.Maybe (Maybe(..))
import Data.Set (Set, member)
import Data.Tuple (uncurry)
import Bindings2 (Bind(..), Bindings, Var, (‚Ü¶))
import DataType2 (Ctr)
import Expr2 (Elim, RecDefs)
import Lattice2 (
   class BoundedSlices, class JoinSemilattice, class Slices, ùîπ, (‚à®), bot, botOf, definedJoin, maybeJoin, neg
)
import Util2 (Endo, MayFail, type (√ó), (√ó), (‚âû), (!), definitely, error, report, unsafeUpdateAt)
import Util.SnocList2 (SnocList(..), (:-))

type Op a = a √ó ùîπ -> Val ùîπ

data Val a =
   Int a Int |
   Float a Number |
   Str a String |
   Record a (Bindings (Val a)) |             -- always saturated
   Constr a Ctr (List (Val a)) |             -- potentially unsaturated
   Matrix a (MatrixRep a) |
   Primitive PrimOp (List (Val a)) |         -- never saturated
   Closure (Env a) (RecDefs a) a (Elim a) |
   Closure2 a (SingletonEnv a) (RecDefs a) (Elim a)

-- op_fwd will be provided with original arguments, op_bwd with original output and arguments
newtype PrimOp = PrimOp {
   arity :: Int,
   op :: List (Val ùîπ) -> Val ùîπ,
   op_fwd :: List (Val ùîπ) -> Val ùîπ,
   op_bwd :: Val ùîπ -> Endo (List (Val ùîπ))
}

-- Environments.
type Env a = Bindings (Val a)
type Env2 a = Map Var (NonEmptyList (Val a))
type SingletonEnv a = Map Var (Val a)

dom :: forall a . Map Var a -> Set Var
dom = keys

lookup' :: forall a . Var -> Env2 a -> MayFail (Val a)
lookup' x Œ≥ = case lookup x Œ≥ of
   Nothing -> report ("variable " <> x <> " not found")
   Just vs -> pure $ head vs

disjUnion :: forall a . Map Var a -> Endo (Map Var a)
disjUnion = unionWith (\_ _ -> error "not disjoint")

update :: forall a . Env2 a -> SingletonEnv a -> Env2 a
update Œ≥ Œ≥' = update' Œ≥ (uncurry Bind <$> toUnfoldable Œ≥')

update' :: forall a . Env2 a -> Bindings (Val a) -> Env2 a
update' Œ≥ Lin              = Œ≥
update' Œ≥ (Œ≥' :- x ‚Ü¶ v)    =
   let vs √ó Œ≥'' = pop x Œ≥ # definitely ("contains " <> x)
   in update' Œ≥'' Œ≥' # insert x (cons' v $ tail vs)

concat :: forall a . Env2 a -> SingletonEnv a -> Env2 a
concat Œ≥ Œ≥' = concat' Œ≥ (uncurry Bind <$> toUnfoldable Œ≥')

concat' :: forall a . Env2 a -> Bindings (Val a) -> Env2 a
concat' Œ≥ Lin            = Œ≥
concat' Œ≥ (Œ≥' :- x ‚Ü¶ v)  =
   case pop x Œ≥ of
   Nothing -> concat' Œ≥ Œ≥' # insert x (singleton v)
   Just (vs √ó Œ≥'') -> concat' Œ≥'' Œ≥' # insert x (v `cons` vs)

restrict :: forall a . Env2 a -> Set Var -> SingletonEnv a
restrict Œ≥ xs = filterKeys (_ `member` xs) Œ≥ <#> head

-- Matrices.
type Array2 a = Array (Array a)
type MatrixRep a = Array2 (Val a) √ó (Int √ó a) √ó (Int √ó a)

insertMatrix :: Int -> Int -> Val ùîπ -> Endo (MatrixRep ùîπ)
insertMatrix i j v (vss √ó h √ó w) =
   let vs_i = vss!(i - 1)
       vss' = unsafeUpdateAt (i - 1) (unsafeUpdateAt (j - 1) v vs_i) vss
   in  vss' √ó h √ó w

-- ======================
-- boilerplate
-- ======================
instance Functor Val where
   map f (Int Œ± n)                  = Int (f Œ±) n
   map f (Float Œ± n)                = Float (f Œ±) n
   map f (Str Œ± str)                = Str (f Œ±) str
   map f (Record Œ± xvs)             = Record (f Œ±) (map (map f) <$> xvs)
   map f (Constr Œ± c vs)            = Constr (f Œ±) c (map f <$> vs)
   -- PureScript can't derive this case
   map f (Matrix Œ± (r √ó iŒ± √ó jŒ≤))   = Matrix (f Œ±) ((map (map f) <$> r) √ó (f <$> iŒ±) √ó (f <$> jŒ≤))
   map f (Primitive œÜ vs)           = Primitive œÜ ((map f) <$> vs)
   map f (Closure œÅ h Œ± œÉ)          = Closure (map (map f) <$> œÅ) (map (map f) <$> h) (f Œ±) (f <$> œÉ)
   map f (Closure2 Œ± Œ≥ œÅ œÉ)         = Closure2 (f Œ±) (map f <$> Œ≥) (map (map f) <$> œÅ) (f <$> œÉ)

instance JoinSemilattice (Val Boolean) where
   join = definedJoin
   neg = (<$>) neg

instance Slices (Val Boolean) where
   maybeJoin (Int Œ± n) (Int Œ±' n')                    = Int (Œ± ‚à® Œ±') <$> (n ‚âû n')
   maybeJoin (Float Œ± n) (Float Œ±' n')                = Float (Œ± ‚à® Œ±') <$> (n ‚âû n')
   maybeJoin (Str Œ± str) (Str Œ±' str')                = Str (Œ± ‚à® Œ±') <$> (str ‚âû str')
   maybeJoin (Record Œ± xvs) (Record Œ±' xvs')          = Record (Œ± ‚à® Œ±') <$> maybeJoin xvs xvs'
   maybeJoin (Constr Œ± c vs) (Constr Œ±' c' us)        = Constr (Œ± ‚à® Œ±') <$> (c ‚âû c') <*> maybeJoin vs us
   maybeJoin (Matrix Œ± (vss √ó (i √ó Œ≤) √ó (j √ó Œ≥))) (Matrix Œ±' (vss' √ó (i' √ó Œ≤') √ó (j' √ó Œ≥'))) =
      Matrix (Œ± ‚à® Œ±') <$> (
         maybeJoin vss vss' `lift2 (√ó)`
         ((flip (√ó) (Œ≤ ‚à® Œ≤')) <$> (i ‚âû i')) `lift2 (√ó)`
         ((flip (√ó) (Œ≥ ‚à® Œ≥')) <$> (j ‚âû j'))
      )
   maybeJoin (Closure œÅ Œ¥ Œ± œÉ) (Closure œÅ' Œ¥' Œ±' œÉ')  =
      Closure <$> maybeJoin œÅ œÅ' <*> maybeJoin Œ¥ Œ¥' <@> Œ± ‚à® Œ±' <*> maybeJoin œÉ œÉ'
   maybeJoin (Closure2 Œ± Œ≥ œÅ œÉ) (Closure2 Œ±' Œ≥' œÅ' œÉ')  =
      Closure2 (Œ± ‚à® Œ±') <$> maybeJoin Œ≥ Œ≥' <*> maybeJoin œÅ œÅ' <*> maybeJoin œÉ œÉ'
   maybeJoin (Primitive œÜ vs) (Primitive _ vs')       = Primitive œÜ <$> maybeJoin vs vs' -- TODO: require œÜ == œÜ'
   maybeJoin _ _                                      = report "Incompatible values"

instance BoundedSlices (Val Boolean) where
   botOf (Int _ n)                  = Int bot n
   botOf (Float _ n)                = Float bot n
   botOf (Str _ str)                = Str bot str
   botOf (Record _ xvs)             = Record bot (botOf <$> xvs)
   botOf (Constr _ c vs)            = Constr bot c (botOf <$> vs)
   -- PureScript can't derive this case
   botOf (Matrix _ (r √ó (i √ó _) √ó (j √ó _))) = Matrix bot ((((<$>) botOf) <$> r) √ó (i √ó bot) √ó (j √ó bot))
   botOf (Primitive œÜ vs)           = Primitive œÜ (botOf <$> vs)
   botOf (Closure Œ≥ œÅ _ œÉ)          = Closure (botOf <$> Œ≥) (botOf <$> œÅ) bot (botOf œÉ)
   botOf (Closure2 _ Œ≥ œÅ œÉ)         = Closure2 bot (botOf <$> Œ≥) (botOf <$> œÅ) (botOf œÉ)
