module Val where

import Prelude hiding (absurd)
import Control.Apply (lift2)
import Data.List (List)
import Data.List.NonEmpty (NonEmptyList, cons, cons', head, singleton, tail)
import Data.Map (Map, filterKeys, keys, insert, lookup, pop, toUnfoldable, unionWith)
import Data.Maybe (Maybe(..))
import Data.Set (Set, member)
import Data.Tuple (uncurry)
import Bindings (Bind(..), Bindings, Var, (‚Ü¶))
import DataType (Ctr)
import Expr (Elim, RecDefs)
import Lattice (
   class BoundedSlices, class JoinSemilattice, class Slices, ùîπ, (‚à®), bot, botOf, definedJoin, maybeJoin, neg
)
import Util (Endo, MayFail, type (√ó), (√ó), (‚âû), (!), definitely, error, report, unsafeUpdateAt)
import Util.SnocList (SnocList(..), (:-))

type Op a = a √ó ùîπ -> Val ùîπ

data Val a =
   Int a Int |
   Float a Number |
   Str a String |
   Record a (Bindings (Val a)) |             -- always saturated
   Constr a Ctr (List (Val a)) |             -- potentially unsaturated
   Matrix a (MatrixRep a) |
   Primitive PrimOp (List (Val a)) |         -- never saturated
   Closure a (SingletonEnv a) (RecDefs a) (Elim a)

-- op_fwd will be provided with original arguments, op_bwd with original output and arguments
newtype PrimOp = PrimOp {
   arity :: Int,
   op :: List (Val ùîπ) -> Val ùîπ,
   op_fwd :: List (Val ùîπ) -> Val ùîπ,
   op_bwd :: Val ùîπ -> Endo (List (Val ùîπ))
}

-- Environments.
type Env a = Map Var (NonEmptyList (Val a))
type SingletonEnv a = Map Var (Val a)

dom :: forall a . Map Var a -> Set Var
dom = keys

lookup' :: forall a . Var -> Env a -> MayFail (Val a)
lookup' x Œ≥ = case lookup x Œ≥ of
   Nothing -> report ("variable " <> x <> " not found")
   Just vs -> pure $ head vs

disjUnion :: forall a . Map Var a -> Endo (Map Var a)
disjUnion = unionWith (\_ _ -> error "not disjoint")

update :: forall a . Env a -> SingletonEnv a -> Env a
update Œ≥ Œ≥' = update' Œ≥ (uncurry Bind <$> toUnfoldable Œ≥')

update' :: forall a . Env a -> Bindings (Val a) -> Env a
update' Œ≥ Lin              = Œ≥
update' Œ≥ (Œ≥' :- x ‚Ü¶ v)    =
   let vs √ó Œ≥'' = pop x Œ≥ # definitely ("contains " <> x)
   in update' Œ≥'' Œ≥' # insert x (cons' v $ tail vs)

concat :: forall a . Env a -> SingletonEnv a -> Env a
concat Œ≥ Œ≥' = concat' Œ≥ (uncurry Bind <$> toUnfoldable Œ≥')

concat' :: forall a . Env a -> Bindings (Val a) -> Env a
concat' Œ≥ Lin            = Œ≥
concat' Œ≥ (Œ≥' :- x ‚Ü¶ v)  =
   case pop x Œ≥ of
   Nothing -> concat' Œ≥ Œ≥' # insert x (singleton v)
   Just (vs √ó Œ≥'') -> concat' Œ≥'' Œ≥' # insert x (v `cons` vs)

restrict :: forall a . Env a -> Set Var -> SingletonEnv a
restrict Œ≥ xs = filterKeys (_ `member` xs) Œ≥ <#> head

-- Matrices.
type Array2 a = Array (Array a)
type MatrixRep a = Array2 (Val a) √ó (Int √ó a) √ó (Int √ó a)

updateMatrix :: Int -> Int -> Endo (Val ùîπ) -> Endo (MatrixRep ùîπ)
updateMatrix i j Œ¥v (vss √ó h √ó w) =
   let vs_i = vss!(i - 1)
       v_j = vs_i!(j - 1)
       vss' = unsafeUpdateAt (i - 1) (unsafeUpdateAt (j - 1) (Œ¥v v_j) vs_i) vss
   in vss' √ó h √ó w

-- ======================
-- boilerplate
-- ======================
instance Functor Val where
   map f (Int Œ± n)                  = Int (f Œ±) n
   map f (Float Œ± n)                = Float (f Œ±) n
   map f (Str Œ± str)                = Str (f Œ±) str
   map f (Record Œ± xvs)             = Record (f Œ±) (map (map f) <$> xvs)
   map f (Constr Œ± c vs)            = Constr (f Œ±) c (map f <$> vs)
   -- PureScript can't derive this case
   map f (Matrix Œ± (r √ó iŒ± √ó jŒ≤))   = Matrix (f Œ±) ((map (map f) <$> r) √ó (f <$> iŒ±) √ó (f <$> jŒ≤))
   map f (Primitive œÜ vs)           = Primitive œÜ ((map f) <$> vs)
   map f (Closure Œ± Œ≥ œÅ œÉ)         = Closure (f Œ±) (map f <$> Œ≥) (map (map f) <$> œÅ) (f <$> œÉ)

instance JoinSemilattice (Val Boolean) where
   join = definedJoin
   neg = (<$>) neg

instance Slices (Val Boolean) where
   maybeJoin (Int Œ± n) (Int Œ±' n')                    = Int (Œ± ‚à® Œ±') <$> (n ‚âû n')
   maybeJoin (Float Œ± n) (Float Œ±' n')                = Float (Œ± ‚à® Œ±') <$> (n ‚âû n')
   maybeJoin (Str Œ± str) (Str Œ±' str')                = Str (Œ± ‚à® Œ±') <$> (str ‚âû str')
   maybeJoin (Record Œ± xvs) (Record Œ±' xvs')          = Record (Œ± ‚à® Œ±') <$> maybeJoin xvs xvs'
   maybeJoin (Constr Œ± c vs) (Constr Œ±' c' us)        = Constr (Œ± ‚à® Œ±') <$> (c ‚âû c') <*> maybeJoin vs us
   maybeJoin (Matrix Œ± (vss √ó (i √ó Œ≤i) √ó (j √ó Œ≤j))) (Matrix Œ±' (vss' √ó (i' √ó Œ≤i') √ó (j' √ó Œ≤j'))) =
      Matrix (Œ± ‚à® Œ±') <$> (
         maybeJoin vss vss' `lift2 (√ó)`
         ((flip (√ó) (Œ≤i ‚à® Œ≤i')) <$> (i ‚âû i')) `lift2 (√ó)`
         ((flip (√ó) (Œ≤j ‚à® Œ≤j')) <$> (j ‚âû j'))
      )
   maybeJoin (Closure Œ± Œ≥ œÅ œÉ) (Closure Œ±' Œ≥' œÅ' œÉ')  =
      Closure (Œ± ‚à® Œ±') <$> maybeJoin Œ≥ Œ≥' <*> maybeJoin œÅ œÅ' <*> maybeJoin œÉ œÉ'
   maybeJoin (Primitive œÜ vs) (Primitive _ vs')       = Primitive œÜ <$> maybeJoin vs vs' -- TODO: require œÜ == œÜ'
   maybeJoin _ _                                      = report "Incompatible values"

instance BoundedSlices (Val Boolean) where
   botOf (Int _ n)                  = Int bot n
   botOf (Float _ n)                = Float bot n
   botOf (Str _ str)                = Str bot str
   botOf (Record _ xvs)             = Record bot (botOf <$> xvs)
   botOf (Constr _ c vs)            = Constr bot c (botOf <$> vs)
   -- PureScript can't derive this case
   botOf (Matrix _ (r √ó (i √ó _) √ó (j √ó _))) = Matrix bot ((((<$>) botOf) <$> r) √ó (i √ó bot) √ó (j √ó bot))
   botOf (Primitive œÜ vs)           = Primitive œÜ (botOf <$> vs)
   botOf (Closure _ Œ≥ œÅ œÉ)         = Closure bot (botOf <$> Œ≥) (botOf <$> œÅ) (botOf œÉ)
