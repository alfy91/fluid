{- Some 'prelude'. -}
letrec
   {- (a → b) → List a → List b -}
   fun map f → fun {
      Nil → Nil;
      Cons(x, xs) → Cons(f x, map f xs)
   }

   {- (a → Bool) → List a → Bool -}
   fun all p → fun {
      Nil → True;
      Cons(x, xs) → match p x as {
         True → all p xs;
         False → False
      }
   }

   {- (a → Bool) → List a → Bool -}
   fun any p → fun {
      Nil → False;
      Cons(x, xs) → match p x as {
         True → True;
         False → any p xs
      }
   }

   {- Ord a → Ord a → Ordering -}
   fun compare x → fun y →
      match x < y as {
         True → LT;
         False → match y < x as {
            True → GT;
            False → EQ
         }
      }

   {- FiniteMap k v → k → Option v -}
   fun lookup {
      Empty → fun k → None;
      NonEmpty(l, (k', v), r) → fun k →
         match compare k k' as {
            LT → lookup l k;
            EQ → Some(v);
            GT → lookup r k
         }
   }

   {- FiniteMap k v → Pair k v → FiniteMap k v -}
   fun insert m → fun (k, v) → match m as {
      Empty → NonEmpty(m, (k, v), m);
      NonEmpty(l, (k', v'), r) →
         match compare k k' as {
            LT → NonEmpty(insert l (k, v), (k', v'), r);
            EQ → NonEmpty(l, (k, v), r);
            GT → NonEmpty(l, (k', v'), insert r (k, v))
         }
   }

   {- FiniteMap k v → List (Pair k v) → FiniteMap k v -}
   fun extend m → fun {
      Nil → m;
      Cons(kv, kvs) → extend (insert m kv) kvs
   }
in
{- To embed Unicode directly into an .lcalc file and have it parse as a Unicode string, I had
   to add "export LANG=en_US.utf8" to my Debian .bashrc_private login script. On Ubuntu the
   default locale seems to support UTF-8. Otherwise, Haskell-style escape sequences will work.
-}
let deadArrow = "→" in
let liveArrow = "\x21a0" in
let explains = "≣" in
let downWedge = "▾" in
let rightWedge = "▸" in
let ellipsis = "…" in
{- Greyscale constants. -}
let traceBackCol = 255 in
let valueBackCol = 215 in
let borderCol = 59 in
let textCol = 0 in
{- Font weights -}
let fwNorm = False in
let fwBold = True in

let fw = fun tv →
       match valueOpt tv as { None → fwNorm; Some(_) → fwBold } 
in
let arrow = fun tv →
       match valueOpt tv as { None → deadArrow; Some(_) → liveArrow } 
in
let max = fun x → fun y →
       match x < y as { True → y; False → x } 
in
let not = fun {
       True → False;
       False → True
    } 
in
{- Slightly weird idiom that allows me to implement a constant function that is guaranteed
   to be run exactly once. -}
let unit = Unit in
{- The datatype associated with a constructor value.
   Value → DataType -}
let dataType = fun v →
       match reify v as {
          Constr(c,_) → valOf (lookup ctrToDataType c);
          ConstInt(_) → error v "[dataType] Expected constructor.";
          ConstStr(_) → error v "[dataType] Expected constructor."
       } 
in
{- Asserts that v has the named data type. Only works for data types, not primitives. -}
let typeCheck = fun datatype → fun v →
       match name (dataType v) == datatype as {
          True → v;
          False → error v ("[typeCheck] Expected " ++ datatype)
       } 
in
letrec
   {- Given a non-empty list of things, return their visualisations, comma-delimited.
      (a → View) → List a → View -}
   fun commaSep1 show → fun {
      Cons(x, xs) →
         let w = show x in
         match xs as {
            Nil → w; {- singleton case -}
            Cons(_, __) → Horiz(w, Horiz(Word(fwNorm, textCol, ","), commaSep1 show xs))
         };
      Nil → error Nil "[commaSep1] Expected non-empty list."
   }
in
{- (a → View) → List a → View -}
let argList =
   fun show → fun xs →
      match xs as {
         Nil → EmptyView;
         Cons(_, __) →
            Horiz(
               Word(fwNorm, textCol, "("),
               Horiz(commaSep1 show xs, Word(fwNorm, textCol, ")"))
            )
      } 
in
{- Bool → Str → View -}
let identBound = fun fw → fun x →
   Horiz(Word(fw, textCol, x), Word(fwNorm, textCol, "⊶")) 
in
{- Place the supplied view on a background, coupling the identity of the background to that
   of the view.
   Int → View → View -}
let onBackground = fun backCol → fun w → Background(backCol, w)
in
{- Str → View -}
let showString = fun str →
   Horiz(
      Word(fwNorm, textCol, "\""),
      Horiz(Word(fwNorm, textCol, str), Word(fwNorm, textCol, "\""))
   ) 
in
letrec
   {- List Match → View -}
   fun matches {
      Nil → EmptyView;
      Cons(Match(p, tv), ms) →
         let args = Word(fwNorm, textCol, "ARGS") in
         let body = Word(fwNorm, textCol, "BODY") in
         let bodySep = Word(fwNorm, textCol, deadArrow) in
         Vert(
            Vert(
                Horiz(args, Horiz(Space, bodySep)),
                Horiz(Space, onBackground traceBackCol body)
            ),
            matches ms
         )
   }

   {- The "innermost" operation trace, and a stack of argument views, for a multi-argument
      application.
      Trace → Pair Traced View -}
   fun multiApp
      App(tv1, tv2, b) →
         let binding_opt = match b as {
                FunBody(ms) → matches ms;
                EmptyBody → EmptyView;
                PrimBody(x) → identBound fwBold x
             } in
         let wArg = Horiz(binding_opt, showTraced tv2) in
         let w = (showTraced tv1, wArg) in
         match trace tv1 as {
            App(_, __, ___) →
               match multiApp (trace tv1) as (wtv, wArgs) → (wtv, Vert(wArgs, wArg));
            EmptyTrace → w;
            OpName(_) → w;
            Var(_) → w;
            Fun(_) → w;
            MatchAs(_, __) → w;
            Let(_, __) → w;
            LetRec(_, __) → w
         }

   {- A stack of constructor arguments.
      (a → View) → List a → View -}
   fun constrArgs show → fun {
      Nil → EmptyView;
      Cons(tv, tvs) → Vert(show tv, constrArgs show tvs)
   }

   {- Crude way of emulating a Show typeclass. Would be nicer if the datatype itself were
      the key, but that would require some kind of Ord instance for Datatype.
      Unit → Map Str (dynamic → View) -}
   fun showInstances _ →
      extend Empty
         Cons(("Closure", showClosure),
         Cons(("List", showList),
         Cons(("Pair", showPair),
         Cons(("PrimOp", showPrimOp),
         Cons(("Trace", showTrace),
         Cons(("Traced", showTraced),
         Cons(("Unit", showUnit),
         Cons(("View", showView), Nil))))))))

   {- Only works for values of data types at the moment.
      dynamic → View) -}
   fun showInstance v →
      lookup (showInstances unit) (name (dataType v))

   {- TODO: need to visualise the meta-level jump here.
      View → View -}
   fun showView v → v

   {- Unit → View -}
   fun showUnit _ → onBackground valueBackCol Word(fwNorm, textCol, "()")

   {- Pair a b → View -}
   fun showPair (x, y) →
      let wx = Horiz(onBackground valueBackCol Word(fwNorm, textCol, "("), showValue x) in
      let wy = Horiz(showValue y, onBackground valueBackCol Word(fwNorm, textCol, ")")) in
      Horiz(wx, Horiz(onBackground valueBackCol Word(fwNorm, textCol, ","), wy))

   {- List a → View -}
   fun showList {
      Nil → onBackground valueBackCol Word(fwNorm, textCol, "[]");
      Cons(x, xs) →
         Horiz(showValue x, Horiz(onBackground valueBackCol Word(fwNorm, textCol, ":"), showValue xs))
   }

   {- Re-use trace-visualisation code for closure bodies. Ignore environment for now. -}
   fun showClosure Closure(_, __, func) → showTrace func

   {- See 0.5.3/0.5.4 release notes for why we treat constructor expressions as constructor values.
      dynamic → View -}
   fun showValue v' →
      let v = reify v' in
      RoundedCell(
         match v as { Constr(_, __) → Some(borderCol); ConstInt(_) → None; ConstStr(_) → None },
         match v as {
            ConstStr(str) → showString str;
            ConstInt(n) → Word(fwNorm, textCol, intToString n);
            Constr(c, tvs) →
               {- This test needs to go here because showInstance currently only defined for non-primitives. -}
               match showInstance v' as {
                  Some(show) → show v';
                  None → Horiz(Word(fwNorm, textCol, c), argList showTraced tvs)
               }
         }
      )

   {- PrimOp → Str -}
   fun primOpName {
      UnaryPrimOp(name) → name;
      BinaryPrimOp(name) → name;
      UnaryPartialPrimOp(name, _, __) → name;
      Proj(name) → name
   }

   {- A bit simplistic, but ok for now.
      PrimOp → View -}
   fun showPrimOp op → Word(fwNorm, textCol, primOpName)

   {- TODO: liveness should affect binder visualisation.
      List Definition → View -}
   fun showDefs {
      Nil → EmptyView;
      Cons(Definition(name, init), defs) →
         Vert(Horiz(identBound fwNorm name, showTraced init), showDefs defs)
   }

   {- Present a recursive definition like a regular traced (functional) value.
      List RecBinding → View -}
   fun showRecBindings {
      Nil → EmptyView;
      Cons(RecBinding(RecDefinition(x, f), _), bindings) →
         Vert(
            Horiz(identBound fwNorm x, showTrace f),
            showRecBindings bindings
         )
   }

   {- TODO: migrate the following code.

   A branch visualised as a traced-value view. Would rather vertically compose the header than
   extend the traced-value view as we do here; see 0.5.8 notes for discussion. First argument is
   containing case expression.
   Traced → Branch → View
   fun branch tv → fun br →
      let pattern = match br as {
             BranchCtr(p,_) → showValue (reflect p);
             BranchOtherwise(_) → Word(fwBold, textCol, "otherwise")
          } in
      let header = Horiz(pattern, Horiz(Space, Word(fw (body br), textCol, arrow (body br)))) in
      let wbr = showTraced (body br) in
      extendTraceView
         wbr
         (fun wbr → Vert(header, match valueOpt tv as { Some(_) → wbr; None → Horiz(Space, wbr) }))

   The view of the single active branch of those supplied. The first parameter is the containing case
   expression.
   Traced → List Branch → View
   fun liveBranch tv → fun
      Cons(br, brs) →
         match valueOpt (body br) as {
            None → liveBranch tv brs;
            _ → branch tv br
         }

   Vertical composition of views of all the supplied branches, which are assumed to be dead. (This is
   for visualising the bodies of functional values.) The first parameter is the containing case
   expression.
   Traced → List Branch → View
   fun allBranches tv → fun {
      Nil → EmptyView;
      Cons(br, brs) → Vert(branch tv br, allBranches tv brs)
   }

   Case(tv', ms) →
      let header = Horiz(
             Word(fwBold, textCol, "case"),
             Horiz(Space, Horiz(showTraced tv', Horiz(Space, Word(fwBold, textCol, "of"))))
          ) in
      let body = match valueOpt tv as {
             None → showTerminal (allBranches tv ms);
             Some(_) → liveBranch tv ms
          } in
      extendTraceView body (fun ms → Vert(header, ms)); -}

   {- Trace → View -}
   fun showTrace t → match t as {
      MatchAs(tv, ms) →
         Vert(
            Horiz(
               Horiz(Word(fwBold, textCol, "match"), Space),
               Horiz(showTraced tv, Word(fwBold, textCol, "as"))
            ),
            matches ms
         );
      EmptyTrace → EmptyView;
      Fun(ms) → Vert(Word(fwBold, textCol, "fun"), Horiz(Space, matches ms));
      OpName(op) →
         onBackground valueBackCol Word(fwNorm, textCol, op);
      Var(x) →
         Word(fwNorm, textCol, x);
      App(_, __, appBody) →
         match multiApp t as 
            (op, args) → 
                let header = Horiz(op, Horiz(Space, args)) in
                match appBody as {
                    FunBody(ms) → Vert(header, matches ms);
                    EmptyBody → header;
                    PrimBody(_) → Word(fwNorm, textCol, "PRIM-BODY")
                };
      Let(defs, body) →
         Vert(Vert(Word(fwBold, textCol, "let"), Horiz(Space, showDefs defs)), showTrace body);
      LetRec(defs, body) →
         Vert(Vert(Word(fwBold, textCol, "letrec"), Horiz(Space, showRecBindings defs)), showTrace body)
   }

   {- Traced → View -}
   fun showTraced {
      Traced(t, _, v) →
         RoundedCell(Some(borderCol), Horiz(showTrace t, onBackground valueBackCol (showValue v)))
   }
in
showTraced tv
