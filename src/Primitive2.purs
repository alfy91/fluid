module Primitive2 where

import Prelude hiding (absurd, apply)
import Data.Either (Either(..))
import Data.Foldable (foldl)
import Data.Int (ceil, floor, toNumber)
import Data.List (List(..), (:))
import Debug.Trace (trace)
import Math (log, pow)
import Bindings (Bindings(..), (:+:), (‚Ü¶))
import DataType (Ctr, cCons, cFalse, cPair, cTrue)
import Lattice (ùîπ, (‚àß))
import Util (Endo, type (√ó), (√ó), type (+), (!), absurd, error)

type Op a = a √ó ùîπ -> Val ùîπ
type MatrixRep a = Array (Array (Val a)) √ó (Int √ó a) √ó (Int √ó a)

data Val a =
   Int a Int |
   Float a Number |
   Str a String |
   Constr a Ctr (List (Val a)) |
   Matrix a (MatrixRep a) |
   Primitive  (Val ùîπ -> Val ùîπ)

instance showVal :: Show (Val Boolean) where
   show (Int Œ± n)       = show n <> "_" <> show Œ±
   show (Float Œ± n)     = show n <> "_" <> show Œ±
   show (Str Œ± str)     = show str <> "_" <> show Œ±
   show (Constr _ _ _)  = error "todo"
   show (Matrix _ _)    = error "todo"
   show (Primitive op)  = error "todo"

getŒ± :: Val ùîπ -> ùîπ
getŒ± (Int Œ± _)       = Œ±
getŒ± (Float Œ± _)     = Œ±
getŒ± (Str Œ± _)       = Œ±
getŒ± (Constr Œ± _ _)  = Œ±
getŒ± _         = error absurd

setŒ± :: ùîπ -> Endo (Val ùîπ)
setŒ± Œ± (Int _ n)        = Int Œ± n
setŒ± Œ± (Float _ n)      = Float Œ± n
setŒ± Œ± (Str _ str)      = Str Œ± str
setŒ± Œ± (Constr _ c vs)  = Constr Œ± c vs
setŒ± _ _                = error absurd

class To a where
   to :: Val ùîπ -> a √ó ùîπ

class From a where
   from :: a √ó ùîπ -> Val ùîπ

instance fromVal :: From (Val Boolean) where
   from (v √ó Œ±) = setŒ± Œ± v

instance toInt :: To Int where
   to (Int Œ± n)   = n √ó Œ±
   to _           = error "Int expected"

instance fromInt :: From Int where
   from (n √ó Œ±) = Int Œ± n

instance fromNumber :: From Number where
   from (n √ó Œ±) = Float Œ± n

instance toString :: To String where
   to (Str Œ± str) = str √ó Œ±
   to _           = error "Str expected"

instance fromString :: From String where
   from (str √ó Œ±) = Str Œ± str

instance toIntOrNumber :: To (Int + Number) where
   to (Int Œ± n)    = Left n √ó Œ±
   to (Float Œ± n)  = Right n √ó Œ±
   to _            = error "Int or Float expected"

instance fromIntOrNumber :: From (Int + Number) where
   from (Left n √ó Œ±)    = Int Œ± n
   from (Right n √ó Œ±)   = Float Œ± n

instance toIntOrNumberOrString :: To (Either (Either Int Number) String) where
   to (Int Œ± n)   = Left (Left n) √ó Œ±
   to (Float Œ± n) = Left (Right n) √ó Œ±
   to (Str Œ± n)   = Right n √ó Œ±
   to _           = error "Int, Float or Str expected"

instance toIntAndInt :: To (Int √ó Boolean √ó (Int √ó Boolean)) where
   to (Constr Œ± c (v : v' : Nil)) | c == cPair  = to v √ó to v' √ó Œ±
   to _                                         = error "Pair expected"

instance toMatrixRep :: To (Array (Array (Val Boolean)) √ó (Int √ó Boolean) √ó (Int √ó Boolean)) where
   to (Matrix Œ± (vss √ó i √ó j))   = vss √ó i √ó j √ó Œ±
   to _                          = error "Matrix expected"

from1 :: forall a b . To a => From b => (a √ó ùîπ -> b √ó ùîπ) -> Val ùîπ
from1 op = Primitive (to >>> op >>> from)

from2 :: forall a b c . To a => To b => From c => (a √ó ùîπ -> b √ó ùîπ -> c √ó ùîπ) -> Val ùîπ
from2 op = Primitive (to >>> op >>> from1)

apply :: Val ùîπ -> Val ùîπ -> Val ùîπ
apply (Primitive op)   = op
apply _                = error absurd

depends :: forall a b . (a -> b) -> a √ó ùîπ -> b √ó ùîπ
depends op (x √ó Œ±) = op x √ó Œ±

dependsBoth :: forall a b c . (a -> b -> c) -> a √ó ùîπ -> b √ó ùîπ -> c √ó ùîπ
dependsBoth op (x √ó Œ±) (y √ó Œ≤) = x `op` y √ó (Œ± ‚àß Œ≤)

dependsNeither :: forall a b c . (a -> b -> c) -> a √ó ùîπ -> b √ó ùîπ -> c √ó ùîπ
dependsNeither op (x √ó _) (y √ó _) = x `op` y √ó true

class DependsBinary a b c where
   dependsNonZero :: (a -> b -> c) -> a √ó ùîπ -> b √ó ùîπ -> c √ó ùîπ

-- If both are false, we depend on the first.
instance dependsNonZeroInt :: DependsBinary Int Int a where
   dependsNonZero op (x √ó Œ±) (y √ó Œ≤) =
      x `op` y √ó if x == 0 then Œ± else if y == 0 then Œ≤ else Œ± ‚àß Œ≤

instance dependsNonZeroNumber :: DependsBinary Number Number a where
   dependsNonZero op (x √ó Œ±) (y √ó Œ≤) =
      x `op` y √ó if x == 0.0 then Œ± else if y == 0.0 then Œ≤ else Œ± ‚àß Œ≤

instance dependsNonZeroIntOrNumber :: DependsBinary (Int + Number) (Int + Number) a where
   dependsNonZero op (x √ó Œ±) (y √ó Œ≤) =
      x `op` y √ó
      if x `((==) `union2'` (==))` (Left 0)
      then Œ±
      else if y `((==) `union2'` (==))` (Left 0) then Œ≤ else Œ± ‚àß Œ≤

instance fromBoolean :: From Boolean where
   from (true √ó Œ±)   = Constr Œ± cTrue Nil
   from (false √ó Œ±)  = Constr Œ± cFalse Nil

primitives :: Bindings Val ùîπ
primitives = foldl (:+:) Empty [
   -- some signatures are specified for clarity or to drive instance resolution
   -- PureScript's / and pow aren't defined at Int -> Int -> Number, so roll our own
   "+"         ‚Ü¶ from2 (dependsBoth ((+) `union2` (+))),
   "-"         ‚Ü¶ from2 (dependsBoth ((-) `union2` (-))),
   "*"         ‚Ü¶ from2 (dependsNonZero ((*) `union2` (*))),
   "**"        ‚Ü¶ from2 (dependsNonZero ((\x y -> toNumber x `pow` toNumber y) `union2'` pow)),
   "/"         ‚Ü¶ from2 (dependsNonZero ((\x y -> toNumber x / toNumber y)  `union2'` (/))),
   "=="        ‚Ü¶ from2 (dependsBoth ((==) `union2'` (==) `unionDisj` (==))),
   "/="        ‚Ü¶ from2 (dependsBoth ((/=) `union2'` (/=) `unionDisj` (==))),
   "<"         ‚Ü¶ from2 (dependsBoth ((<)  `union2'` (<)  `unionDisj` (==))),
   ">"         ‚Ü¶ from2 (dependsBoth ((>)  `union2'` (>)  `unionDisj` (==))),
   "<="        ‚Ü¶ from2 (dependsBoth ((<=) `union2'` (<=) `unionDisj` (==))),
   ">="        ‚Ü¶ from2 (dependsBoth ((>=) `union2'` (>=) `unionDisj` (==))),
   "++"        ‚Ü¶ from2 (dependsBoth ((<>) :: String -> String -> String)),
   ":"         ‚Ü¶ Constr false cCons Nil,
   "!"         ‚Ü¶ from2 (dependsNeither matrixLookup),
   "ceiling"   ‚Ü¶ from1 (depends ceil),
   "debugLog"  ‚Ü¶ from1 (depends debugLog),
   "dims"      ‚Ü¶ from1 dims,
   "div"       ‚Ü¶ from2 (dependsNonZero (div :: Int -> Int -> Int)),
   "error"     ‚Ü¶ from1 (depends  (error :: String -> Boolean)),
   "floor"     ‚Ü¶ from1 (depends floor),
   "log"       ‚Ü¶ from1 (depends ((toNumber >>> log) `union` log)),
   "numToStr"  ‚Ü¶ from1 (depends (show `union` show))
]

debugLog :: Val ùîπ -> Val ùîπ
debugLog x = trace x (const x)

dims :: (Array (Array (Val ùîπ)) √ó (Int √ó Int)) √ó ùîπ -> (Val ùîπ √ó Val ùîπ) √ó ùîπ
dims = error "todo"

matrixLookup :: MatrixRep ùîπ -> (Int √ó ùîπ) √ó (Int √ó ùîπ) -> Val ùîπ
matrixLookup (vss √ó _ √ó _) (i √ó _ √ó (j √ó _)) = vss!(i - 1)!(j - 1)

-- Could improve this a bit with some type class shenanigans, but not straightforward.
union :: forall a . (Int -> a) -> (Number -> a) -> Int + Number -> a
union f _ (Left x)   = f x
union _ f (Right x)  = f x

union2 :: (Int -> Int -> Int) -> (Number -> Number -> Number) -> Int + Number -> Int + Number -> Int + Number
union2 f _ (Left x) (Left y)     = Left $ f x y
union2 _ f (Left x) (Right y)    = Right $ f (toNumber x) y
union2 _ f (Right x) (Right y)   = Right $ f x y
union2 _ f (Right x) (Left y)    = Right $ f x (toNumber y)

union2' :: forall a . (Int -> Int -> a) -> (Number -> Number -> a) -> Int + Number -> Int + Number -> a
union2' f _ (Left x) (Left y)    = f x y
union2' _ f (Left x) (Right y)   = f (toNumber x) y
union2' _ f (Right x) (Right y)  = f x y
union2' _ f (Right x) (Left y)   = f x (toNumber y)

unionDisj :: forall a b . (b -> b -> a) -> (String -> String -> a) -> b + String -> b + String -> a
unionDisj f _ (Left x) (Left y)   = f x y
unionDisj _ _ (Left _) (Right _)  = error "Non-uniform argument types"
unionDisj _ f (Right x) (Right y) = f x y
unionDisj _ _ (Right _) (Left _)  = error "Non-uniform argument types"

testPrim :: Val ùîπ
testPrim = apply (apply (from2 (dependsNonZero ((*) `union2` (*)))) (Int false 0)) (Int true 0)
